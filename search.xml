<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【团队管理】【团队知识系统指导】]]></title>
    <url>%2FTM_KnowledgeSystem_guide.html</url>
    <content type="text"><![CDATA[文章导读前段时间在梳理如何管理团队知识系统，自己在头条上面偶尔看到了一篇比较好的文章，此处进行镜像备份。如果有侵权，联系我第一时间删除。 文章目标 为什么要进行团队知识系统 团队知识系统管理要怎么搭建 原文了解团队知识管理体系1.知识管理是什么？知识管理目前仍没有一个标准的定义，众多定义中比较全面的一个是：在组织中建构一个量化与质化的知识系统，让组织中的资讯与知识，透过获得、创造、分享、整合、记录、存取、更新、创新等过程，不断的回馈到知识系统内，形成永不间断的累积个人与组织的知识成为组织智慧的循环，在企业组织中成为管理与应用的智慧资本，有助于企业做出正确的决策，以应对市场的变化。 2.为什么要搭建团队知识管理体系？ 知识作为最有价值的资产需要妥善管理，以便它保证能够在最需要的时间将最需要的知识传送给最需要的人，这样可以帮助人们共享信息, 并进而将其通过不同的方式付诸实践, 终极目标是协助企业实现价值最大化。 如何搭建团队知识管理体系第1步：普及 创建团队知识库是一个很简单的动作，只要在某个平台上创建一个团队，我们甚至就可以说创建完成了。然而搭建不同，搭建是一个持续一段时间的行为。搭建包括前期的准备、规划，后期的管理、完善等等，直至形成一个完整的可持续的体系。 如何让团队知识管理体系长久地运营下去才是难题，而能否解决这个难题的关键，正是团队是否认可这种方式。只有大家认可了，才会主动来做这件事情。前期需要对团队进行知识管理意识的普及，如跟大家分享其他企业利用这样的管理方式的例子，如让大家先尝试个人知识管理等。目次在于让大家认识到知识管理的有效性，继而愿意来尝试这种方法。 第2步：规划 规划是非常关键的一步，切勿提出要搭建团队知识管理体系后，只是简单地要求成员来上传自己的文档，后续就不再予以关注。 如果要建立一个团队知识管理体系，一定要指定专人负责规划，职责到人才能够把事情做到位。至于如何制定具体的规则，可以结合难点，进行一场头脑风暴。不仅能够充分发挥团体的智慧，还能够了解每一个人的想法。 在整个规划中，搭建知识架构这件事非常重要。后期在要求成员扩充内容时，可能成员本人并不知道该写什么，就会以架构作为参考来选题。所以架构本身就带有指导的性质，切不可敷衍。 规划中的两个难点： 难点1：怎样把隐性知识显性化？ 这里涉及到了关于知识的两个名词。隐性知识指的是未被表述的知识，如技能、秘诀等；显性知识则是以书面文字、图表和数学公式加以表述的知识，更加直观。一般来讲，隐性知识比显性知识更完善、更能创造价值，隐性知识的挖掘和利用能力，将成为个人和组织成功的关键。显性知识则必须能很快地再转换为隐性知识，否则它的真实价值就不复存在。因为显性知识转换为企业员工隐性知识的过程，一般都是知识应用的过程或知识成为生产力的过程。 怎样把隐性知识显性化，通俗地来说就是怎样把优秀人才的工作经验转化大家看得懂的文字或流程等。一个可考虑的方式，是在每一个项目或较复杂工作做成果总结的时候，规定项目负责人对整个过程进行一次复盘。即除了提交成果以外，还要对整个项目从头到尾进行一次梳理，归纳出优点和不足。这样其他成员也能够间接从中吸取到经验教训。 难点2：如何快速找到对自己有用的信息？ 完善的分类模式+脑图+准确标题=快速查找 团队知识库会随时间而扩大，当目录层级非常多的时候，如何找到所需的信息成了一大难题。如果不在归纳梳理上花功夫，知识库里的内容就容易成为一个“杂书间”，完全没有条理，来找“书”的人也根本无法找到对自己有用的“书”。实际上，解决这个问题所要的事也很像一个图书管理员的日常。 首先要建立一个合理的分类架构，这件事情要由对团队工作所有相关领域都极熟悉的元老级人物来做。因为他们知道什么是合理构架，知道团队需要什么样的内容，知道什么样的内容具有复用性，会从更严谨的角度出发来搭建架构。新人不够熟悉业务领域，所以无法搭建起一个实用合理的知识架构。 然后要在已经创建了分类架构的基础上，制作一张全局预览图。比较建议的方式是做一张可以实时更新的云端协作思维导图，随着知识库内容的增加而更新。团队成员想查找信息的时候，只要打开脑图就能够找到大概的位置。因为文件夹目录只能看到当下的一层，而要精准地找到某个文件，则需要看到完整的结构。 除此之外，在最初制定管理规则的时候，对文档标题进行比较严格的规定，要求标题中包括比较详细的关键字，也有助于查找。 第3步：管理与完善 规划中制定的规则在实施中还会发现各种不完善的地方，需要在后期的实施中持续优化。甚至可以做A/B 测试来观察不同的规则所带来的效果。规则方面，非常重要的一点是适度，不能让成员感到要求过分。这种用规则来进行约束的方法，可以称之为“硬管理”手段。 与“硬管理”相对的还有“软管理”，指的是为达成目的所使用的非强制手段。在“软管理”中，管理者的作用十分关键。一方面能够起到表率作用：管理者自己分享一些经验、行业观察等，带起分享知识的风气。另一方面，管理者可以鼓励有潜力的成员，让员工感到被认可，从而主动分享自己的知识。还可以表扬对知识库贡献比较大的成员，增加他们的成就感，同时也让其他的成员愿意花心思来做这件事。 实际上，最重要的是创造一个乐于分享的和谐氛围，让大家自发性地来分享知识，而不是因为被push才不得不写。 此外，还要明白每个团队都有自己的特点，产品团队、研发团队、运营团队等等，在很多方面都有自己的特性。当前企业文化、员工素质、运营模式也是需要考虑的方面。应以专人管理辅以员工自发，并随其发展而逐步调整两者比例。 管理难点：怎样让团队成员持续分享自己的知识？ 经济奖励+精神奖励=持续分享 分享知识这件事本身就是有门槛的一件事，要求持续分享则是更高的目标。对于成员而言，团队知识管理体系常见的驱动力有两种：经济价值和个人价值。 要求成员主动而持续地分享，最有效的还属经济驱动。常见形式是有直接的奖金鼓励，以及间接的积分或悬赏等鼓励方式。个人价值方面，则可以提供成员更多成就感，以及更优的工作机会。这两者激励机制都是反馈周期越短，效果越明显。 Tips：先试错，再实行 实际上搭建一个完整的团队知识分享体系是一个比较复杂的过程，需要投入许多成本和精力，所以可以先小范围进行尝试，采用产品中MVP（最小化可行产品）的理念来进行试错，等到状态比较理想的时候再在团队全体成员中实行。挑选团队知识管理平台想要搭建起一个完整的团队知识管理体系，必然要借助团队知识管理平台，用以管理存放团队知识文档。好的平台能让搭建团队知识体系这件事变得更简单，从而达到事半功倍的效果。 1.对团队知识管理平台的要求 一个好的团队知识平台至少要做到以下几个方面： （1）稳定，知识安全不丢失。 文档的安全是首要考虑因素，所以平台最好由大厂提供。 （2）存储空间大，且内容不泄密。 团队知识、资料包括许多机密，平台一定要谨慎选择，非常小的第三方平台可能没有那么有保障。 （3）个人文档和团队文档加以区分。 方便成员使用，因为成员也有自己的知识库，需要加以区分。 （4）多级目录，多种成员权限，多种文档权限。 多种目录是为了分类与层级管理。多种权限则是leader的管理需要。 （5）利于查看使用，分享便捷。 使用方便和分享快速很重要。就使用而言，需要符合多终端的特点，这样才能满足不同的应用场景。分享则包括成员间的分享，以及向外部人员的分享，轻量操作为佳。 （6）最好还提供多人共同编辑，而且编辑完能够直接保存到平台。 多人编辑能够让工作流程更简单，不需要传输下载。直接保存到平台也是非常重要的功能。 很多工具都把“编辑”与“保存”分离开了，编辑依托于别的工具，到保存的时候在纳入管理保存工具之下。流程的衔接性不友好，要在多个系统中切换。复杂的操作流程会提高分享门槛。 （7）带一些沟通功能，如评论等。 能够对文档进行评论可免去需要来回切换至IM工具的繁琐过程。评论最好是划词评论，能够更清晰地了解评论针对的是哪部分内容。]]></content>
      <categories>
        <category>团队管理</category>
      </categories>
      <tags>
        <tag>团队管理, 团队知识系统，指导</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【团队管理】【团队知识系统】]]></title>
    <url>%2FTM_KnowledgeSystem.html</url>
    <content type="text"><![CDATA[文章导读博主目前算是一名小组的组长，组员有7个。项目还在持续的招人，我的小组规模还在持续的扩张，当然那时因为任务不断在增加。当人员任务多的时候，明显感觉有些力不从心，自己很多的任务无法按时完成，到处给别人救火，还看不到产出。究其原因，主要还是没有一个副手能帮我承担一些工作，一方面老员工的实力不够仅仅在一个领域擅长；另一方面就是新员工成长速度太慢。出于让老员工可以多学习其它的模块，新员工的成长和知识的积累，本人一直在探索有没有一种简单团队知识系统，既方便又好用。今天终于在找到一种合适自己的方法。这里面分享处理，共大家参考。 团队知识系统管理的指导【团队管理】【团队知识系统指导】 具体规划]]></content>
      <categories>
        <category>团队管理</category>
      </categories>
      <tags>
        <tag>团队管理, 团队知识系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【资源】 【优秀博客资源】]]></title>
    <url>%2Fresource_blog.html</url>
    <content type="text"><![CDATA[文章导读自己在完善自己博客的时候，发现了很多优秀的博客，本文随手将其积累下来。 优秀博客 博客名称 简介/标签 Yu’s Notes HEXO TY·Loafer PHP，GO，Nginx，MySQL，linux（少）]]></content>
      <categories>
        <category>资源</category>
      </categories>
      <tags>
        <tag>资源，优秀博客资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【随笔】 【Git教程】]]></title>
    <url>%2Fessay_git.html</url>
    <content type="text"><![CDATA[文章导读白天偶然接触到了廖雪峰写的git教程，随手写下了这个过程记录自己成长的轨迹。 git 教程自己写博客时用的图床是github，昨天在写好多图博客后，准备上传图片的时候，才发现从github上面clone真是慢啊，结果博客文字写差不多了，图片还一个都没有传上去。 【github 下 git clone 特别慢】针对这个问题我从网上检索出一些解决办法，办法中是让修改代理，这些方法尝试后效果并不是太好。然后我就思考，git是否支持仅clone下来一个配置，不包含库中的文件。在这个好奇心驱动下，我了解到了廖雪峰写的git教程。 因为现在的工作中经常接触到git，也积累了不少git的技巧，不过从来没有系统的学习过git，里面一些基本的概念还不是很清楚。从接触到这个教程后发现，这个教程写的真的好，浅显易懂逻辑连贯，很适合初级选手学习，不过这些也是最常用的，学会后，完全可以胜任平时工作中的需要。教程看完了，但还是没有解决我目前遇到的疑问和问题。 我在网上检索了下其他人用的是哪个图床，多个结果中都推荐了七牛云，推荐它的主要原因是限量免费和稳定，大家既然都推荐它肯动有其优势所在。我准备先试试，使用体验在后续使用过程中慢慢输出吧。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔，git教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【游玩】 【白鹿仓】]]></title>
    <url>%2Fplay_bailucang.html</url>
    <content type="text"><![CDATA[文章导读在端午节的三天假日中，两天可自由支配，一天还得加班的情况下。去远了时间不够近了时间多余，城市周边玩耍时间刚刚好。在老婆朋友的推荐下，我们选择了白鹿仓景区。从游玩结束至今已过去一周时间，因为平时工作太忙，过星期时才有时间将游玩的体验码下来。在记录下自己生活的同时，锻炼一下自己的写作能力。 本文分别从景区简介，位置交通，门票优惠，游玩攻略，游玩体验和体验感受共6方面来介绍白鹿仓，力求呈现出来景区完貌。 景区简介白鹿原·白鹿仓景区由陕西锋双集团投资建设，总规划用地2100亩，计划投资35亿元，于上风上水之地打造的全域旅游战略旗舰项目，被誉为推进全域旅游发展示范单位。同时，也是当前国内为数不多的功能齐全、涵盖面广、跨界经营管理的综合智慧景区，是省、市两级人民政府重点项目。 白鹿原·白鹿仓景区顺应时代发展将文化的包容性不断提升，致力于开创民俗文化旅游的新纪元。景区一期由“一仓三营”组成，分别是：“白鹿之仓”、“航空飞行营地”、“温泉房车营地”、“运动体验营地”。 位置交通白鹿仓整体位于西安的东郊。 白鹿仓周边地区位置具体位置：中国陕西省西安市灞桥区狄寨北路368号 在白鹿仓外面有个比较大的停车位，大概有2千多个停车位。 去的时候时跟着导航走的，坐的时公交车。回来的时候直接坐的大巴车, 大巴车到达纺织城地铁口挺方便的。 门票优惠入园免费，园内按照进行收费。 游玩攻略上面是整个园区整体俯视图, 大家可以按照上面的图计划怎么的游玩路线。由于去的仓促也没有怎么准备, 进入景区后有些茫然，前期做些准备还是很有必要。 游玩体验景区外部刚到景区后，景区入口建筑与西安城墙类似，也是由蓝砖修砌而成的一段城墙。 白鹿之仓刚开始进来就是忠孝广场。忠孝广场右转后，就是白鹿原古街。白鹿原古街走到岔口后，其左手边有一个古亭。继续往前走会有一个高大的独木亭。自己在去的时候，那下面有人用秦腔唱诵白鹿仓，自己录制了一段视频。 document.getElementById("muting").style.height=document.getElementById("muting").scrollWidth*0.76+"px"; 在木亭的台阶下面就是大茶楼的百戏广场。 从木亭绕到左侧就可以到达国民街国民街出来后就是望母阁，至此白鹿仓入口区域的景区就是这些了。 滋水河在入口区的沿着河道走，可以到达滋水河边的秦巴路。由于没有规划路线，这里面其实是我们的最后一站，所以没有多少照片。 花海公园从国民街过去后，就是花海公园。 航空飞行营地从花海公园路过，就是航空飞行营地, 营地里面只有热气球。可能处于安全考虑，热气球被几个绳索固定在了地上，只能是原地升空，不过排队的人挺多。 document.getElementById("re").style.height=document.getElementById("re").scrollWidth*0.76+"px"; 温泉房车营地航空飞行营地旁边就是温泉房车营地，这个地方不是开放的。问了下要800-1000元一天，太贵就没进去体验。 萌宠乐园离游乐场不远处有三个室内景区，分别是萌宠乐园，冰雪王国和海洋馆，打完折后每人78元。 当我们子啊冰雪王国前面时，发现可以原地跳远后可以的票，此时心里有一群神兽跑过, 因此冰雪王国前面排队的人特别多。在海洋馆内是有美人鱼表演的，还没到时间点，还需要等待两个小时，按照萌宠乐园-&gt;冰雪王国-&gt;海洋馆顺序打卡，时间刚刚好。 document.getElementById("dongwu").style.height=document.getElementById("dongwu").scrollWidth*0.76+"px"; 冰雪王国 海洋馆 现代农业 游乐园 后记初次长传多图和视频的博文，其中有些图片有问题，后续完善。。。]]></content>
      <categories>
        <category>旅游</category>
      </categories>
      <tags>
        <tag>游玩，白鹿仓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【读书】 【学习力：颠覆职场学习的高效方法】]]></title>
    <url>%2Fbook_xuexili.html</url>
    <content type="text"><![CDATA[文章导读本书中我看到了搭建个人知识体系的关键词，我是举双手赞成这种观点的。本人目前从事linux 嵌入式网络开发，从ipconfig都不了解，到熟知ip网络配置的工具，从业务小白到领域MDE，其中有多少辛酸痛苦只有自己知道。能让自己有长足进步的多亏了自己建立的知识体系，所以看到本书中”搭建个人知识体系”观点时，本人赞同的同时，也多了一份期待。 本文以时间和事件发展的顺序进行布局的，目前还没有建立起来行之有效的读书体系，先以这种结构进行书写。 接触 【内容简介】 有很多要学的内容，但工作忙得没时间学，怎么办？工作了很多年，但知识支离破碎不成体系，怎么办？想转行，但又缺少工作必需的知识和技能，怎么办？《学习力：颠覆职场学习的高效方法》给你一套适合你的职场学习方法，帮你搭建系统的个人知识体系，让你轻松学会各种技能，在短时间内实现岗位能力提升，快速适应一份新工作，或者转入一个新行业。 刚在微信号中接触到学习力推荐的书籍，然后着手了解下。看其封面有学习力、职业学习方法轮、系统、高效、实用等关键字。从其封面上面就可以看到本书的核心内容，可以迅速的学习到一种技能知识，是每个人梦寐以求的能力。从封面来看，本书的内容就是讲解的学习力，我需要的就是这方面的知识，然后准备深度了解下。 网评 【豆瓣】这本书大量的篇幅介绍百度、谷歌搜索去了，有点凑字数。速成只能针对最开始知识最表层的知识，任何深层次的知识都不只是脑图、列表和速度可以挖掘的，要有在不同阶段打轻松仗和硬仗的准备。 【豆瓣】培训机构出的，总体上还是不错的：1、职场上强调高效，学习不妨功利一点，结果至上。2、学会框架思维，事前去查找有无框架可供参考，事后及时总结形成框架供以后反复套用。3、最关键的是要搭建一个自己的知识体系，做到可迁移，学习和工作才会走上快车道。 【亚马逊】论学习，我只服《学习力》看过这个系列的另一本书：《思维力，高效的系统思维》。这个作者的书是我曾经读过的理论书里面最接地气的！到不是说举的例子多么新，但是就是觉得看他讲那些高深理论就是一下子就弄明白了！不是那种有很多看不懂的名词，或者举一些很玄乎的例子，实际上跟理论之间的逻辑关系都很乱的那种书！这本学习力果然也没让我失望。我以前老有一个想法，就是觉得我找工作的时候，我会什么技能就去找什么工作。可看完书之后我发现，其实我可以为了想做什么工作而去学什么技能呀！这个想法让我思路一下子就拓宽了，再也不用觉得做现在的工作没价值又跳不出去。比如说我现在虽然是程序猿，但我学好了项目管理，不就可以去做项目经理了嘛！这个时候，这本书里的学习方法就变得非常实用了！学的快才能早翻身啊！阅读笔记略读阶段 五类学习技巧：搜索技巧文中谈论了如何进行搜索资料，看似挺普通的技能，还需要用大篇幅来进行讲解，是不是有些多余和不专业。我也算是职场老手了，在工作中确实遇到过不少不会用搜索引擎的。这里面的不会用，是方法不正确，导致搜到的结果与预期匹配度低。文中说的几种方法，自己确实也有在用，比如关键词搜索法，关键词逼近法等。但大部分方法还没用到，满满的干货需要自己梳理总结下。 五类学习技巧：阅读技技巧我大概看了下本章节的内容，与我目前对阅读技巧的认知是吻合的，当然我自己还没有达到文中描述的水平。之前看过一些与阅读技巧相关的书籍，比如《书都不会读，你还想成功》，从名字来看就是满满的炫耀和指责，不出意外的书中剧情就是书中主角怎么通过读书从一个小小的职员 一步步走上人生巅峰的。读完手自己跟打了鸡血一样，发誓自己也要通过阅读走上人生巅峰。过了一段时间后，才发现都是扯淡。另外我阅读的一本书《如何阅读一本书》，这本书中包含了很多实操的方法，过程大致与学习力这本书中的相同不过方法会更详细一些，各有千秋吧。到底应该按照哪个里进行建立自己的阅读技巧，在《如何阅读一本书》和《学习力》两书之间选择的话，我更倾向与学习力这本书，因为作为一个普通的初阶阅读选手，掌握一些基本技巧就够了。本章的阅读笔记就到这，这章节的技巧是我急需要的，下来需要细读。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【todo】]]></title>
    <url>%2Ftodo_list.html</url>
    <content type="text"><![CDATA[文章导读罗列需要自己完成的top3任务清单记录任务的完成情况激励自己持续改进 完善个人博客 测试环境搭建过程 《ftp协议》 添加具体的协议报文分析过程 迁移自己csdn文章 输出ipsec vpn 协议 提升逻辑能力途径-1：读书 书名 简介 开始时间 结束时间 进度 金字塔原理 … 2019/6/4 todo 1/4 学习力：颠覆职场学习的高效方法 … 2019/6/13 … 1/4 途径-2：写作写个人博客]]></content>
      <categories>
        <category>todo</category>
      </categories>
      <tags>
        <tag>todo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【技巧】【github】]]></title>
    <url>%2Fskill_github.html</url>
    <content type="text"><![CDATA[添加已有项目到github 新建repository，可以在github网站上直接新建或者使用windows github工具。 进入github repository 项目 在github windows工具中使用git Bash打开项目，使用cd命令进入已有项目根目录下12345git init //在当前项目目录中生成本地git管理,并建立一个隐藏.git目录git add . //添加当前目录中的所有文件到索引git commit -m "first commit" //提交到本地源码库，并附加提交注释git remote add origin https://github.com/test/test.git //添加到远程项目，别名为origingit push -u origin master //把本地源码库push到github 别名为origin的远程项目中，确认提交 问题-1: RT ! [rejected] master -&gt; master (fetch first)在push远程服务器的时候发现出现此错误；原因是没有同步远程的master所以我们需要先同步一下a.–&gt; git pull origin masterb.–&gt; git push origin master 问题-2: ! [rejected] master -&gt; master (non-fast forward)Non-fast-forward的出现原因在于：git仓库中已经有一部分代码，所以它不允许你直接把你的代码覆盖上去。我们这里面是新建的仓，可以直接强推(命令加上-f参数)，如果仓中有其它的代码慎选。1git push -u origin master -f //把本地源码库push到github 别名为origin的远程项目中，确认提交]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown 技巧]]></title>
    <url>%2Fskill_markdown.html</url>
    <content type="text"><![CDATA[文章导读记录自己接触的markdown技巧 技巧阵列 技巧 备注 语法简介 表格样式调整与自适应优化 代码语法高亮 画图表 包含主要包含流程图，表格直接使用typora来实现。本来计划用图表来画框图，实测不行太麻烦 技巧笔记…]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>markdown,技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【金字塔原理】]]></title>
    <url>%2Fbook_jinzitayuanli.html</url>
    <content type="text"><![CDATA[文章导读原文]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【养老】]]></title>
    <url>%2Fparents_yanglao.html</url>
    <content type="text"><![CDATA[补钙 补钙知识补钙不能单纯补钙，需要：钙 + 维生素D3 + 维生素K2 补钙形态钙片，奶粉 补钙产品]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【读书】]]></title>
    <url>%2Fbook_list.html</url>
    <content type="text"><![CDATA[table { width: 100% } table th:nth-of-type(1) { width: 25%; } table th:nth-of-type(2) { width: 75%; } 分类 链接 思维逻辑 金字塔原理学习力：颠覆职场学习的高效方法]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【网络编程】【邻居表】]]></title>
    <url>%2Fnet_network_neigh.html</url>
    <content type="text"><![CDATA[原帖:http://blog.csdn.net/qy532846454/article/details/6806197 内核版本：2.6.34这部分的重点是三个核心的数据结构-邻居表、邻居缓存、代理邻居表，以及NUD状态转移图。 总的来说，要成功添加一条邻居表项，需要满足两个条件：1. 本机使用该表项；2. 对方主机进行了确认。同时，表项的添加引入了NUD(Neighbour Unreachability Detection)机制，从创建NUD_NONE到可用NUD_REACHABLE需要经历一系列状态转移，而根据达到两个条件顺序的不同，可以分为两条路线： 先引用再确认- NUD_NONE -&gt; NUD_INCOMPLETE -&gt; NUD_REACHABLE 先确认再引用- NUD_NONE -&gt; NUD_STALE -&gt; NUD_DELAY -&gt; NUD_PROBE -&gt; NUD_REACHABLE 下面还是从接收函数入手，当匹配号协议号是0x0806，会调用ARP模块的接收函数arp_rcv()。arp_rcv() ARP接收函数 首先是对arp协议头进行检查，比如大小是否足够，头部各数值是否正确等，这里略过代码，直接向下看。每个协议处理都一样，如果被多个协议占有，则拷贝一份。[cpp] view plain copyif ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL) goto out_of_mem; NEIGH_CB(skb)实际就是skb-&gt;cb，在skb声明为u8 char[48]，它用作每个协议模块的私有数据区(control buffer)，每个协议模块可以根据自身需求在其中存储私有数据。而arp模块就利用了它存储控制结构neighbour_cb，它声明如下，占8字节。这个控制结构在代理ARP中使用工作队列时会发挥作用，sched_next代表下次被调度的时间，flags是标志。[cpp] view plain copymemset(NEIGH_CB(skb), 0, sizeof(struct neighbour_cb));struct neighbour_cb { unsigned long sched_next; unsigned int flags;}; 函数最后调用arp_process，其间插入netfilter(关于netfilter，参见前篇：http://hi.csdn.net/link.php?url=http://blog.csdn.net%2Fqy532846454)，作为开始处理ARP报文的起点。[cpp] view plain copyreturn NF_HOOK(NFPROTO_ARP, NF_ARP_IN, skb, dev, NULL, arp_process); arp_process() 这个函数开始对报文进行处理，首先会从skb中取出arp报头部分的信息，如sha, sip, tha, tip等，这部分可查阅代码，这里略过。ARP不会查询环路地址和组播地址，因为它们没有对应的mac地址，因此遇到这两类地址，直接退出。[cpp] view plain copyif (ipv4_is_loopback(tip) || ipv4_is_multicast(tip)) goto out; 如果收到的是重复地址检测报文，并且本机占用了检测了地址，则调用arp_send发送响应。对于重复地址检测报文(ARP报文中源IP为全0)，它所带有的邻居表项信息还没通过检测，此时缓存它显然没有意义，也许下一刻就有其它主机声明它非法，因此，重复地址检测报文中的信息不会加入邻居表中。[cpp] view plain copyif (sip == 0) { if (arp-&gt;ar_op == htons(ARPOP_REQUEST) &amp;&amp; inet_addr_type(net, tip) == RTN_LOCAL &amp;&amp; !arp_ignore(in_dev, sip, tip)) arp_send(ARPOP_REPLY, ETH_P_ARP, sip, dev, tip, sha, dev-&gt;dev_addr, sha); goto out;} 下面要处理的地址解析报文，并且要解析的地址在路由表中存在[cpp] view plain copyif (arp-&gt;ar_op == htons(ARPOP_REQUEST) &amp;&amp; ip_route_input(skb, tip, sip, 0, dev) == 0) 第一种情况，如果要解析的是本机地址，则调用neigh_event_ns()，并根据查到的邻居表项n发送ARP响应报文。这里neigh_event_ns的功能是在arp_tbl中查找是否已含有对方主机的地址信息，如果没有，则进行创建，然后会调用neigh_update来更新状态。收到对方主机的请求报文，会导致状态迁移到NUD_STALE。[cpp] view plain copyif (addr_type == RTN_LOCAL) { …… if (!dont_send) { n = neigh_event_ns(&amp;arp_tbl, sha, &amp;sip, dev); if (n) { arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dev-&gt;dev_addr,sha); neigh_release(n); } } goto out;} #NUD_INCOMPLETE也迁移到NUD_STALE，作何解释？ 第二种情况，如果要解析的不是本机地址，则要判断是否支持转发，是否支持代理ARP(代理ARP是陆由器的功能，因此能转发是先决条件)，如果满足条件，那么按照代理ARP流程处理。首先无论如何，主机得通了存在这样一个邻居，因此要在在arp_tbl中查找并(如果不存在)创建相应邻居表项；然后，对于代理ARP，这个流程实际上会执行两遍，第一遍走else部分，第二遍走if部分。第一次的else代码段会触发定时器，通过定时器引发报文重新执行arp_process函数，并走if部分。 -第一遍的else部分：调用pneigh_enqueue()将报文skb加入tbl-&gt;proxy_queue队列，同时设置NEIGH_CB(skb)的值，具体可看后见的代理表项处理。 -第二遍的if部分，发送ARP响应报文，行使代理ARP的功能。 [cpp] view plain copyelse if (IN_DEV_FORWARD(in_dev)) { if (addr_type == RTN_UNICAST &amp;&amp; (arp_fwd_proxy(in_dev, dev, rt) || arp_fwd_pvlan(in_dev, dev, rt, sip, tip) || pneigh_lookup(&amp;arp_tbl, net, &amp;tip, dev, 0))) { n = neigh_event_ns(&amp;arp_tbl, sha, &amp;sip, dev); if (n) neigh_release(n); if (NEIGH_CB(skb)-&gt;flags &amp; LOCALLY_ENQUEUED || skb-&gt;pkt_type == PACKET_HOST || in_dev-&gt;arp_parms-&gt;proxy_delay == 0) { arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dev-&gt;dev_addr,sha); } else { pneigh_enqueue(&amp;arp_tbl, in_dev-&gt;arp_parms, skb); in_dev_put(in_dev); return 0; } goto out; }} 补充：neigh_event_ns()与neigh_release()配套使用并不代表创建后又被释放，neigh被释放的条件是neigh-&gt;refcnt==0，但neigh创建时的refcnt=1，而neigh_event_ns会使refcnt+1，neigh_release会使-1，此时refcnt的值还是1，只有当下次单独调用neigh_release时才会被释放。 查找是否已存在这样一个邻居表项。如果ARP报文是发往本机的响应报文，那么neigh会更新为NUD_REACHABLE状态；否则，维持原状态不变。#个人认为，这段代码是处理NUD_INCOMPLETE/NUD_PROBE/NUD_DELAY向NUD_REACHABLE迁移的，但如果一台主机A发送一个对本机的ARP响应报文，那么会导致neigh从NUD_NONE直接迁移到NUD_REACHABLE，当然，按照正常流程，一个ARP响应报文肯定是由于本机发送了ARP请求报文，那样neigh已经处于NUD_INCOMPLETE状态了。[cpp] view plain copyn = __neigh_lookup(&amp;arp_tbl, &amp;sip, dev, 0);if (n) { int state = NUD_REACHABLE; int override; override = time_after(jiffies, n-&gt;updated + n-&gt;parms-&gt;locktime); if (arp-&gt;ar_op != htons(ARPOP_REPLY) || skb-&gt;pkt_type != PACKET_HOST) state = NUD_STALE; neigh_update(n, sha, state, override ? NEIGH_UPDATE_F_OVERRIDE : 0); neigh_release(n);} 实际上，arp_process是接收到ARP报文的处理函数，它涉及到的是邻居表项在收到arp请求和响应的情况，下图反映了arp_process中所涉及的状态转移：收到arp请求，NUD_NONE -&gt; NUD_STALE；收到arp响应，NUD_INCOMPLETE/NUD_DELAY/NUD_PROBE -&gt; NUD_REACHABLE。根据之前分析，我认为还存在NUD_NONE -&gt; NUD_REACHABLE和NUD_INCOMPLETE -&gt; NUD_STALE的转移，作何解释？ NUD状态 每个邻居表项在生效前都要经历一系列的状态迁移，每个状态都有不同的含义，在前面已经多次提到了NUD状态。要添加一条有效的邻居表项，有效途径有两条： 先引用再确认- NUD_NONE -&gt; NUD_INCOMPLETE -&gt; NUD_REACHABLE 先确认再引用- NUD_NONE -&gt; NUD_STALE -&gt; NUD_DELAY -&gt; NUD_PROBE -&gt; NUD_REACHABLE 其中neigh_timer_handler定时器、neigh_periodic_work工作队列会异步的更改NUD状态，neigh_timer_handler用于NUD_INCOMPLETE, NUD_DELAY, NUD_PROBE, NUD_REACHABLE状态；neigh_periodic_work用于NUD_STALE。注意neigh_timer_handler是每个表项一个的，而neigh_periodic_work是唯一的，NUD_STALE状态的表项没必要单独使用定时器，定期检查过期就可以了，这样大大节省了资源。 neigh_update则专门用于更新表项状态，neigh_send_event则是解析表项时的状态更新，能更新表项的函数很多，这里不一一列出。 neigh_timer_handler 定时器函数 当neigh处于NUD_INCOMPLETE, NUD_DELAY, NUD_PEOBE, NUD_REACHABLE时会添加定时器，即neigh_timer_handler，它处理各个状态在定时器到期时的情况。 当neigh处于NUD_REACHABLE状态时，根据NUD的状态转移图，它有三种转移可能，分别对应下面三个条件语句。neigh-&gt;confirmed代表最近收到来自对应邻居项的报文时间，neigh-&gt;used代表最近使用该邻居项的时间。 -如果超时，但期间收到对方的报文，不更改状态，并重置超时时间为neigh-&gt;confirmed+reachable_time； -如果超时，期间未收到对方报文，但主机使用过该项，则迁移至NUD_DELAY状态，并重置超时时间为neigh-&gt;used+delay_probe_time； -如果超时，且既未收到对方报文，也未使用过该项，则怀疑该项可能不可用了，迁移至NUD_STALE状态，而不是立即删除，neigh_periodic_work()会定时的清除NUD_STALE状态的表项。[cpp] view plain copyif (state &amp; NUD_REACHABLE) { if (time_before_eq(now, neigh-&gt;confirmed + neigh-&gt;parms-&gt;reachable_time)) { NEIGH_PRINTK2(“neigh %p is still alive.\n”, neigh); next = neigh-&gt;confirmed + neigh-&gt;parms-&gt;reachable_time; } else if (time_before_eq(now, neigh-&gt;used + neigh-&gt;parms-&gt;delay_probe_time)) { NEIGH_PRINTK2(“neigh %p is delayed.\n”, neigh); neigh-&gt;nud_state = NUD_DELAY; neigh-&gt;updated = jiffies; neigh_suspect(neigh); next = now + neigh-&gt;parms-&gt;delay_probe_time; } else { NEIGH_PRINTK2(“neigh %p is suspected.\n”, neigh); neigh-&gt;nud_state = NUD_STALE; neigh-&gt;updated = jiffies; neigh_suspect(neigh); notify = 1; }} 下图是对上面表项处于NUD_REACHABLE状态时，定时器到期后3种情形的示意图： 当neigh处于NUD_DELAY状态时，根据NUD的状态转移图，它有二种转移可能，分别对应下面二个条件语句。 -如果超时，期间收到对方报文，迁移至NUD_REACHABLE，记录下次检查时间到next； -如果超时，期间未收到对方的报文，迁移至NUD_PROBE，记录下次检查时间到next。 在NUD_STALE-&gt;NUD_PROBE中间还插入NUD_DELAY状态，是为了减少ARP包的数目，期望在定时时间内会收到对方的确认报文，而不必再进行地址解析。 [cpp] view plain copyelse if (state &amp; NUD_DELAY) { if (time_before_eq(now, neigh-&gt;confirmed + neigh-&gt;parms-&gt;delay_probe_time)) { NEIGH_PRINTK2(“neigh %p is now reachable.\n”, neigh); neigh-&gt;nud_state = NUD_REACHABLE; neigh-&gt;updated = jiffies; neigh_connect(neigh); notify = 1; next = neigh-&gt;confirmed + neigh-&gt;parms-&gt;reachable_time; } else { NEIGH_PRINTK2(“neigh %p is probed.\n”, neigh); neigh-&gt;nud_state = NUD_PROBE; neigh-&gt;updated = jiffies; atomic_set(&amp;neigh-&gt;probes, 0); next = now + neigh-&gt;parms-&gt;retrans_time; }} 当neigh处于NUD_PROBE或NUD_INCOMPLETE状态时，记录下次检查时间到next，因为这两种状态需要发送ARP解析报文，它们过程的迁移依赖于ARP解析的进程。[cpp] view plain copyelse { / NUD_PROBE|NUD_INCOMPLETE / next = now + neigh-&gt;parms-&gt;retrans_time;} 经过定时器超时后的状态转移，如果neigh处于NUD_PROBE或NUD_INCOMPLETE，则会发送ARP报文，先会检查报文发送的次数，如果超过了限度，表明对方主机没有回应，则neigh进入NUD_FAILED，被释放掉。[cpp] view plain copyif ((neigh-&gt;nud_state &amp; (NUD_INCOMPLETE | NUD_PROBE)) &amp;&amp; atomic_read(&amp;neigh-&gt;probes) &gt;= neigh_max_probes(neigh)) { neigh-&gt;nud_state = NUD_FAILED; notify = 1; neigh_invalidate(neigh);} 检查完后，如果还未超过限度，则会发送ARP报文，neigh-&gt;ops-&gt;solicit在创建表项neigh时被赋值，一般是arp_solicit，并且增加探测计算neigh-&gt;probes。[cpp] view plain copyif (neigh-&gt;nud_state &amp; (NUD_INCOMPLETE | NUD_PROBE)) { struct sk_buff skb = skb_peek(&amp;neigh-&gt;arp_queue); / keep skb alive even if arp_queue overflows */ if (skb) skb = skb_copy(skb, GFP_ATOMIC); write_unlock(&amp;neigh-&gt;lock); neigh-&gt;ops-&gt;solicit(neigh, skb); atomic_inc(&amp;neigh-&gt;probes); kfree_skb(skb);} 实际上，neigh_timer_handler处理启用了定时器状态超时的情况，下图反映了neigh_timer_handler中所涉及的状态转移，值得注意的是NUD_DELAY -&gt; NUD_REACHABLE的状态转移，在arp_process中也提到过，收到arp reply时会有表项状态NUD_DELAY -&gt; NUD_REACHABLE。它们两者的区别在于arp_process处理的是arp的确认报文，而neigh_timer_handler处理的是4层的确认报文。 neigh_periodic_work NUD_STALE状态的定时函数 当neigh处于NUD_STALE状态时，此时它等待一段时间，主机引用到它，从而转入NUD_DELAY状态；没有引用，则转入NUD_FAIL，被释放。不同于NUD_INCOMPLETE、NUD_DELAY、NUD_PROBE、NUD_REACHABLE状态时的定时器，这里使用的异步机制，通过定期触发neigh_periodic_work()来检查NUD_STALE状态。[cpp] view plain copytbl-&gt;parms.base_reachable_time = 30 HZ 当初始化邻居表时，添加了neigh_periodic_work工作 neigh_table_init() -&gt; neigh_table_init_no_netlink()：[cpp] view plain copyINIT_DELAYED_WORK_DEFERRABLE(&amp;tbl-&gt;gc_work, neigh_periodic_work); 当neigh_periodic_work执行时，首先计算到达时间(reachable_time)，其中要注意的是[cpp] view plain copyp-&gt;reachable_time = neigh_rand_reach_time(p-&gt;base_reachable_time);unsigned long neigh_rand_reach_time(unsigned long base){ return (base ? (net_random() % base) + (base &gt;&gt; 1) : 0);} 因此，reachable_time实际取值是1/2 base ~ 2/3 base，而base = base_reachable_time，当表项处于NUD_REACHABLE状态时，会启动一个定时器，时长为reachable_time，即一个表项在不被使用时存活时间是1/2 base_reachable_time ~ 2/3 base_reachable_time。 然后它会遍历整个邻居表，每个hash_buckets的每个表项，如果在gc_staletime内仍未被引用过，则会从邻居表中清除。[cpp] view plain copyfor (i = 0 ; i &lt;= tbl-&gt;hash_mask; i++) { np = &amp;tbl-&gt;hash_buckets[i]; while ((n = np) != NULL) { …..if (atomic_read(&amp;n-&gt;refcnt) == 1 &amp;&amp; (state == NUD_FAILED || time_after(jiffies, n-&gt;used + n-&gt;parms-&gt;gc_staletime))) { np = n-&gt;next; n-&gt;dead = 1; write_unlock(&amp;n-&gt;lock); neigh_cleanup_and_release(n); continue; } ……} 在工作最后，再次添加该工作到队列中，并延时1/2 base_reachable_time开始执行，这样，完成了neigh_periodic_work工作每隔1/2 base_reachable_time执行一次。schedule_delayed_work(&amp;tbl-&gt;gc_work, tbl-&gt;parms.base_reachable_time &gt;&gt; 1); neigh_periodic_work定期执行，但要保证表项不会刚添加就被neigh_periodic_work清理掉，这里的策略是：gc_staletime大于1/2 base_reachable_time。默认的，gc_staletime = 30，base_reachable_time = 30。也就是说，neigh_periodic_work会每15HZ执行一次，但表项在NUD_STALE的存活时间是30HZ，这样，保证了每项在最差情况下也有(30 - 15)HZ的生命周期。neigh_update 邻居表项状态更新 如果新状态是非有效(!NUD_VALID)，那么要做的就是删除该表项：停止定时器neigh_del_timer，设置neigh状态nud_state为新状态new。除此之外，当是NUD_INCOMPLETE或NUD_PROBE状态时，可能有暂时因为地址没有解析而暂存在neigh-&gt;arp_queue中的报文，而现在表项更新到NUD_FAILED，即解析无法成功，那么这么暂存的报文也只能被丢弃neigh_invalidate。[cpp] view plain copyif (!(new &amp; NUD_VALID)) { neigh_del_timer(neigh); if (old &amp; NUD_CONNECTED) neigh_suspect(neigh); neigh-&gt;nud_state = new; err = 0; notify = old &amp; NUD_VALID; if ((old &amp; (NUD_INCOMPLETE | NUD_PROBE)) &amp;&amp; (new &amp; NUD_FAILED)) { neigh_invalidate(neigh); notify = 1; } goto out;} 中间这段代码是对比表项的地址是否发生了变化，略过。#个人认为NUD_REACHABLE状态时，新状态为NUD_STALE是在下面这段代码里面除去了，因为NUD_REACHABLE状态更好，不应该回退到NUD_STALE状态。但是当是NUD_DELAY, NUD_PROBE, NUD_INCOMPLETE时仍会被更新到NUD_STALE状态，对此很不解???[cpp] view plain copyelse { if (lladdr == neigh-&gt;ha &amp;&amp; new == NUD_STALE &amp;&amp; ((flags &amp; NEIGH_UPDATE_F_WEAK_OVERRIDE) || (old &amp; NUD_CONNECTED))) new = old;} 新旧状态不同时，首先删除定时器，如果新状态需要定时器，则重新设置定时器，最后设置表项neigh为新状态new。[cpp] view plain copyif (new != old) { neigh_del_timer(neigh); if (new &amp; NUD_IN_TIMER) neigh_add_timer(neigh, (jiffies + ((new &amp; NUD_REACHABLE) ? neigh-&gt;parms-&gt;reachable_time : 0))); neigh-&gt;nud_state = new;} 如果邻居表项中的地址发生了更新，有了新的地址值lladdr，那么更新表项地址neigh-&gt;ha，并更新与此表项相关的所有缓存表项neigh_update_hhs。[cpp] view plain copyif (lladdr != neigh-&gt;ha) { memcpy(&amp;neigh-&gt;ha, lladdr, dev-&gt;addr_len); neigh_update_hhs(neigh); if (!(new &amp; NUD_CONNECTED)) neigh-&gt;confirmed = jiffies - (neigh-&gt;parms-&gt;base_reachable_time &lt;&lt; 1); notify = 1;} 如果表项状态从非有效(!NUD_VALID)迁移到有效(NUD_VALID)，且此表项上的arp_queue上有项，表明之前有报文因为地址无法解析在暂存在了arp_queue上。此时表项地址解析完成，变为有效状态，从arp_queue中取出所有待发送的报文skb，发送出去n1-&gt;output(skb)，并清空表项的arp_queue。[cpp] view plain copyif (!(old &amp; NUD_VALID)) { struct sk_buff skb;while (neigh-&gt;nud_state &amp; NUD_VALID &amp;&amp; (skb = __skb_dequeue(&amp;neigh-&gt;arp_queue)) != NULL) { struct neighbour n1 = neigh; write_unlock_bh(&amp;neigh-&gt;lock); / On shaper/eql skb-&gt;dst-&gt;neighbour != neigh :( / if (skb_dst(skb) &amp;&amp; skb_dst(skb)-&gt;neighbour) n1 = skb_dst(skb)-&gt;neighbour; n1-&gt;output(skb); write_lock_bh(&amp;neigh-&gt;lock); } skb_queue_purge(&amp;neigh-&gt;arp_queue);} neigh_event_send 当主机需要解析地址，会调用neigh_resolve_output，主机引用表项明显会涉及到表项的NUD状态迁移，NUD_NONE-&gt;NUD_INCOMPLETE，NUD_STALE-&gt;NUD_DELAY。 neigh_event_send -&gt; __neigh_event_send 只处理nud_state在NUD_NONE, NUD_STALE, NUD_INCOMPLETE状态时的情况：[cpp] view plain copyif (neigh-&gt;nud_state &amp; (NUD_CONNECTED | NUD_DELAY | NUD_PROBE)) goto out_unlock_bh; 不处于NUD_STALE和NUD_INCOMPLETE状态，则只能是NUD_NONE。此时主机要用到该邻居表项(注意是通过neigh_resolve_output进入的)，但还没有，因此要通过ARP进行解析，并且此时没有收到对方发来的任何报文，要进行的ARP是广播形式。 在发送ARP报文时有3个参数- ucast_probes, mcast_probes, app_probes，分别代表单播次数，广播次数，app_probes比较特殊，一般情况下为0，当使用了arpd守护进程时才会设置它的值。如果已经收到过对方的报文，即知道了对方的MAC-IP，ARP解析会使用单播形式，次数由ucast_probes决定；如果未收到过对方报文，此时ARP解析只能使用广播形式，次数由mcasat_probes决定。 当mcast_probes有值时，neigh进入NUD_INCOMPLETE状态，设置定时器，注意此时neigh_probes(表示已经进行探测的次数)初始化为ucast_probes，目的是只进行mcast_probes次广播；当mcast_probes值为0时(表明当前配置不允许解析)，neigh进入NUD_FAILED状态，被清除。[cpp] view plain copyif (!(neigh-&gt;nud_state &amp; (NUD_STALE | NUD_INCOMPLETE))) { if (neigh-&gt;parms-&gt;mcast_probes + neigh-&gt;parms-&gt;app_probes) { atomic_set(&amp;neigh-&gt;probes, neigh-&gt;parms-&gt;ucast_probes); neigh-&gt;nud_state = NUD_INCOMPLETE; neigh-&gt;updated = jiffies; neigh_add_timer(neigh, now + 1); } else { neigh-&gt;nud_state = NUD_FAILED; neigh-&gt;updated = jiffies; write_unlock_bh(&amp;neigh-&gt;lock); kfree_skb(skb); return 1; }} 当neigh处于NUD_STALE状态时，根据NUD的状态转移图，主机引用到了该邻居表项，neigh转移至NUD_DELAY状态，设置定时器。[cpp] view plain copyelse if (neigh-&gt;nud_state &amp; NUD_STALE) { NEIGH_PRINTK2(“neigh %p is delayed.\n”, neigh); neigh-&gt;nud_state = NUD_DELAY; neigh-&gt;updated = jiffies; neigh_add_timer(neigh, jiffies + neigh-&gt;parms-&gt;delay_probe_time);} 当neigh处于NUD_INCOMPLETE状态时，需要发送ARP报文进行地址解析，skb_queue_tail(&amp;neigh-&gt;arp_queue, skb)的作用就是先把要发送的报文缓存起来，放到neigh-&gt;arp_queue链表中，当完成地址解析，再从neigh-&gt;arp_queue取出报文，并发送出去。[cpp] view plain copyif (neigh-&gt;nud_state == NUD_INCOMPLETE) { if (skb) { if (skb_queue_len(&amp;neigh-&gt;arp_queue) &gt;= neigh-&gt;parms-&gt;queue_len) { struct sk_buff *buff; buff = skb_dequeue(&amp;neigh-&gt;arp_queue); kfree_skb(buff); NEIGH_CACHE_STAT_INC(neigh-&gt;tbl, unres_discards); } __skb_queue_tail(&amp;neigh-&gt;arp_queue, skb); } rc = 1;} 邻居表的操作neigh_create 创建邻居表项 首先为新的邻居表项struct neighbour分配空间，并做一些初始化。传入的参数tbl就是全局量arp_tbl，分配空间的大小是tbl-&gt;entry_size，而这个值在声明arp_tbl时初始化为sizeof(struct neighbour) + 4，多出的4个字节就是key值存放的地方。[cpp] view plain copyn = neigh_alloc(tbl); 拷贝key(即IP地址)到primary_key，而primary_key就是紧接neighbour的4个字节，看下struct neighbor的声明 - u8 primary_key[0]；设置n-&gt;dev指向接收到报文的网卡设备dev。[cpp] view plain copymemcpy(n-&gt;primary_key, pkey, key_len);n-&gt;dev = dev; 哈希表是牺牲空间换时间，保证均匀度很重要，一旦某个表项的值过多，链表查找会降低性能。因此当表项数目entries大于初始分配大小hash_mask+1时，执行neigh_hash_grow将哈希表空间倍增，这也是内核使用哈希表时常用的方法，可变大小的哈希表。[cpp] view plain copyif (atomic_read(&amp;tbl-&gt;entries) &gt; (tbl-&gt;hash_mask + 1)) neigh_hash_grow(tbl, (tbl-&gt;hash_mask + 1) &lt;&lt; 1); 通过pkey和dev计算哈希值，决定插入tbl-&gt;hash_buckets的表项。[cpp] view plain copyhash_val = tbl-&gt;hash(pkey, dev) &amp; tbl-&gt;hash_mask; 搜索tbl-&gt;hash_buckets[hash_val]项，如果创建的新ARP表项已存在，则退出；否则将其n插入该项的链表头。[cpp] view plain copyfor (n1 = tbl-&gt;hash_buckets[hash_val]; n1; n1 = n1-&gt;next) { if (dev == n1-&gt;dev &amp;&amp; !memcmp(n1-&gt;primary_key, pkey, key_len)) { neigh_hold(n1); rc = n1; goto out_tbl_unlock; }}n-&gt;next = tbl-&gt;hash_buckets[hash_val];tbl-&gt;hash_buckets[hash_val] = n; 附一张创建ARP表项并插入到hash_buckets的图： neigh_lookup 查找ARP表项 查找函数很简单，以IP地址和网卡设备(即pkey和dev)计算哈希值hash_val，然后在tbl-&gt;hash_buckets查找相应项。[cpp] view plain copyhash_val = tbl-&gt;hash(pkey, dev);for (n = tbl-&gt;hash_buckets[hash_val &amp; tbl-&gt;hash_mask]; n; n = n-&gt;next) { if (dev == n-&gt;dev &amp;&amp; !memcmp(n-&gt;primary_key, pkey, key_len)) { neigh_hold(n); NEIGH_CACHE_STAT_INC(tbl, hits); break; }} 代理ARP 代理ARP的相关知识查阅google。要明确代理ARP功能是针对陆由器的(或者说是具有转发功能的主机)。开启ARP代理后，会对查询不在本网段的ARP请求包回应。 回到之前的arp_process代码，处理代理ARP的情况，这实际就是进行代理ARP的条件，IN_DEV_FORWARD是支持转发，RTN_UNICAST是与路由直连，arp_fwd_proxy表示设备支持代理行为，arp_fwd_pvlan表示支持代理同设备进出，pneigh_lookup表示目的地址的代理。这两种arp_fwd_proxy和arp_fwd_pvlan都只是网卡设备的一种性质，pneigh_lookup则是一张代理邻居表，它的内容都是手动添加或删除的，三种策略任一一种满足都可以进行代理ARP。[cpp] view plain copyelse if (IN_DEV_FORWARD(in_dev)) { if (addr_type == RTN_UNICAST &amp;&amp; (arp_fwd_proxy(in_dev, dev, rt) || arp_fwd_pvlan(in_dev, dev, rt, sip, tip) || pneigh_lookup(&amp;arp_tbl, net, &amp;tip, dev, 0))) pneigh_lookup 查找或添加代理邻居表项[proxy neighbour] 以[pkey=tip, key_len=4]计算hash值，执行pneigh_lookup_1在phash_buckets中查找。[cpp] view plain copyu32 hash_val = pneigh_hash(pkey, key_len);n = pneigh_lookup_1(tbl-&gt;phash_buckets[hash_val], net, pkey, key_len, dev); 如果在phash_buckets中查找到，或者不需要创建新表项，则函数返回，此时它的功能仅仅是lookup。[cpp] view plain copyif (n || !creat) goto out; 而当传入参数create=1时，则它的功能不仅是lookup，还会在表项不存在时create。同neighbour结构一样，键值pkey存储在pneigh结构的后面，这样当pkey变化时，修改十分容易。创建操作很直观，为pneigh和pkey分配空间，初始化些变量，最后插入phash_buckets。[cpp] view plain copyn = kmalloc(sizeof(*n) + key_len, GFP_KERNEL);……write_pnet(&amp;n-&gt;net, hold_net(net));memcpy(n-&gt;key, pkey, key_len);……n-&gt;next = tbl-&gt;phash_buckets[hash_val];tbl-&gt;phash_buckets[hash_val] = n; pneigh_enqueue 将报文加入代理队列 首先计算下次调度的时间，这是一个随机值，记录到sched_next中；设置flags|=LOCALLY_ENQUEUED表明报文是本地加入的。[cpp] view plain copyunsigned long sched_next = now + (net_random() % p-&gt;proxy_delay);……NEIGH_CB(skb)-&gt;sched_next = sched_next;NEIGH_CB(skb)-&gt;flags |= LOCALLY_ENQUEUED; 然后将报文加入proxy_queue，并设置定时器proxy_timer，下次超时时间为刚计算的值sched_next，这样，下次超时时就会处理proxy_queue队列中的报文。[cpp] view plain copy__skb_queue_tail(&amp;tbl-&gt;proxy_queue, skb);mod_timer(&amp;tbl-&gt;proxy_timer, sched_next); 这里的tbl当然是arp_tbl，它的proxy_timer是在初始化时设置的arp_init() -&gt; neigh_table_init_no_netlink()中：[cpp] view plain copysetup_timer(&amp;tbl-&gt;proxy_timer, neigh_proxy_process, (unsigned long)tbl); neigh_proxy_process 代理ARP的定时器 skb_queue_walk_safe如同for循环一样，它遍历proxy_queue，一个个取出其中的报文skb，查看报文的调度时间sched_next与当前时间now的差值。 如果tdif&lt;=0则表明调度时间已到或已过，报文要被处理了，从proxy_queue上取出该报文，调用tbl-&gt;proxy_redo重新发送报文，tbl-&gt;proxy_redo也是在arp初始化时赋值的，实际上就是arp_process()函数。结合上面的分析，它会执行arp_process中代理ARP处理的else部分，发送响应报文。 如果tdif&gt;0则表明调度时间还未到，else if部分的功能就是记录下最近要过期的调度时间到sched_next。[cpp] view plain copyskb_queue_walk_safe(&amp;tbl-&gt;proxy_queue, skb, n) { long tdif = NEIGH_CB(skb)-&gt;sched_next - now; if (tdif &lt;= 0) { struct net_device *dev = skb-&gt;dev; __skb_unlink(skb, &amp;tbl-&gt;proxy_queue); if (tbl-&gt;proxy_redo &amp;&amp; netif_running(dev)) tbl-&gt;proxy_redo(skb); else kfree_skb(skb); dev_put(dev); } else if (!sched_next || tdif &lt; sched_next) sched_next = tdif;} 重新设置proxy_timer的定时器，下次超时时间为刚刚记录下的最近要调度的时间sched_next + 当前时间jiffies。[cpp] view plain copydel_timer(&amp;tbl-&gt;proxy_timer);if (sched_next) mod_timer(&amp;tbl-&gt;proxy_timer, jiffies + sched_next); 以一张简单的图来说明ARP代理的处理过程，过程一是入队列等待，过程二是出队列发送。不立即处理ARP代理请求报文的原因是为了性能，收到报文后会启动定时器，超时时间是一个随机变量，保证了在大量主机同时进行此类请求时不会形成太大的负担。 邻居表缓存 邻居表缓存中存储的就是二层报头，如果缓存的报头正好被用到，那么直接从邻居表缓存中取出报文就行了，而不用再额外的构造报头，加快了协议栈的响应速度。neigh_hh_init 创建新的邻居表缓存 当发送报文时，如果还没有对方主机MAC地址，则调用neigh_resove_output进行地址解析，此时会判断dst-&gt;hh为NULL时，就会调用neigh_hh_init创建邻居表缓存，加速下次的报文发送。 首先在邻居表项所链的所有邻居表缓存项n-&gt;hh匹配协议号protocol，找到，则说明已有缓存，不必再创建，neigh_hh_init会直接返回；未找到，则会创建新的缓存项hh。[cpp] view plain copyfor (hh = n-&gt;hh; hh; hh = hh-&gt;hh_next) if (hh-&gt;hh_type == protocol) break; 下面代码段创建了新的缓存项hh，并初始化了hh的内容，其中dev-&gt;header_ops-&gt;cache会赋值hh-&gt;hh_data，即[SRCMAC, DSTMAC, TYPE]。如果赋值失败，释放掉刚才分配的hh；如果赋值成功，将hh链入n-&gt;hh的链表，并根据NUD状态赋值hh-&gt;hh_output。[cpp] view plain copyif (!hh &amp;&amp; (hh = kzalloc(sizeof(*hh), GFP_ATOMIC)) != NULL) { seqlock_init(&amp;hh-&gt;hh_lock); hh-&gt;hh_type = protocol; atomic_set(&amp;hh-&gt;hh_refcnt, 0); hh-&gt;hh_next = NULL; if (dev-&gt;header_ops-&gt;cache(n, hh)) { kfree(hh); hh = NULL; } else { atomic_inc(&amp;hh-&gt;hh_refcnt); hh-&gt;hh_next = n-&gt;hh; n-&gt;hh = hh; if (n-&gt;nud_state &amp; NUD_CONNECTED) hh-&gt;hh_output = n-&gt;ops-&gt;hh_output; else hh-&gt;hh_output = n-&gt;ops-&gt;output; }} 最后，创建成功的hh，陆由缓存dst-&gt;hh指向新创建的hh。[cpp] view plain copyif (hh) { atomic_inc(&amp;hh-&gt;hh_refcnt); dst-&gt;hh = hh;} 从hh的创建过程可以看出，通过邻居表项neighbour的缓存hh可以遍历所有的与neighbour相关的缓存(即目的MAC相同，但协议不同)；通过dst的缓存hh只能指向相关的一个缓存(尽管dst-&gt;hh-&gt;hh_next也许有值，但只会使用dst-&gt;hh)。这里解释了为什么neighbour和dst都有hh指针指向缓存项，可以这么说，neighbour指向的hh是全部的，dst指向的hh是特定一个。两者的作用：在发送报文时查找完陆由表找到dst后，会直接用dst-&gt;hh，得到以太网头；而当远程主机MAC地址变更时，通过dst-&gt;neighbour-&gt;hh可以遍历所有缓存项，从而全部更改，而用dst-&gt;hh得一个个查找，几乎是无法完成的。可以这么说，dst-&gt;hh是使用时用的，neigh-&gt;hh是管理时用的。 neigh_update_hhs 更新缓存项 更新缓存项更新的实际就是缓存项的MAC地址。比如当收到一个报文，以它源IP为键值在邻居表中查找到的neighbour表项的n-&gt;ha与报文源MAC值不同时，说明对方主机的MAC地址发生了变更，此时就需要更新所有以旧MAC生成的hh为新MAC。邻居表项是以IP为键值查找的，因此通过IP可以查找相关的邻居表项neigh，前面说过neigh-&gt;hh可以遍历所有以之相关的缓存项，所以遍历它，并调用update函数。以以太网卡为例，update = neigh-&gt;dev-&gt;header_ops-&gt;cache_update ==&gt; eth_header_cache_update，而eth_header_cache_update函数就是用新的MAC地址覆盖hh-&gt;data中的旧MAC地址。 neigh_update_hhs函数也说明了neighbour-&gt;hh指针的作用。[cpp] view plain copyfor (hh = neigh-&gt;hh; hh; hh = hh-&gt;hh_next) { write_seqlock_bh(&amp;hh-&gt;hh_lock); update(hh, neigh-&gt;dev, neigh-&gt;ha); write_sequnlock_bh(&amp;hh-&gt;hh_lock);} 补充：缓存项hh的生命期从创建时起，会一直持续到邻居表项被删除，也就是调用neigh_destroy时，删除neigh-&gt;hh指向的所有缓存项。参考：《Understanding Linux Network Internals》]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络编程, 邻居表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【网络编程】【邻居表】]]></title>
    <url>%2Fnet_network_neigh.html</url>
    <content type="text"><![CDATA[为什么要有锁机制？共享资源被并发使用的时候，当有可能破坏资源的一致性的时候，就需要一种同步机制，保证资源可以被使用正确。 通俗地理解锁机制厕所浴室：一种共享资源爸爸、妈妈、小孩：用户 当有一个人进入厕所后，该资源已经被占用，就会将门锁住。另一个人只能排队等待，直到资源被释放（开门离开），下一个人才能使用。 锁机制概览 名称 定义 特点 应用场景 备注 原子操作（atomic） 所谓原子操作，就是该操作绝不会在执行完毕前被任何其他任务或事件打断，也就说，它的最小的执行单位，不可能有比它更小的执行单位，因此这里的原子实际是使用了物理学里的物质微粒的概念。 需要硬件的支持。都使用汇编语言实现 原子操作主要用于实现资源计数，很多引用计数(refcnt)就是通过原子操作实现的 互斥锁（mutex） 每个对象都对应于一个可称为” 互斥锁” 的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。 同一时间只能有一个任务持有互斥锁，而且只有这个任务可以对互斥锁进行解锁。互斥锁不能用于中断上下文。互斥锁比当前的内核信号量选项更快，并且更加紧凑。会引起调用者睡眠。 自旋锁（Spanlock） 自旋锁与互斥锁有点类似，只是自旋锁不会引起调用者睡眠。 如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。由于自旋锁使用者一般保持锁时间非常短，因此选择自旋而不是睡眠是非常必要的，自旋锁的效率远高于互斥锁 调用资源的时间短。可以在任何上下文使用 顺序锁（seqlock） 用于能够区分读与写的场合，并且是读操作很多、写操作很少，写操作的优先权大于读操作。 RCU(read-copy-update) RCU也是用于能够区分读与写的场合，并且也是读多写少，但是读操作的优先权大于写操作（与seqlock相反） 信号量 Linux内核的信号量在概念和原理上与用户态的SystemV的IPC机制信号量是一样的，但是它绝不可能在内核之外使用，因此它与SystemV的IPC机制信号量毫不相干 信号量和读写信号量适合于保持时间较长的情况，它们会导致调用者睡眠，因此只能在进程上下文使用（_trylock的变种能够在中断上下文使用） 信号量可以类比为一把锁（共享资源）对应多把钥匙（信号量），只有持有钥匙的人才能开锁]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络编程, 邻居表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【网络】【RIB表与FIB表、ARP表与FDB表】]]></title>
    <url>%2Fnet_network_arp.html</url>
    <content type="text"><![CDATA[转自:http://blog.csdn.net/lanlicen/article/details/6333694 RIB与FIB的区别： RIB：路由表 FIB：转发信息表 FIB表更多是出现在需要快速转发的路由器上，这种路由器上的路由表条目通常都达成千上万条，如果按照传统的检索路由表进行转发的方式，其转发效率很低，FIB表作为路由表的一种精简形式出现，通常只记录常用的表项。当需要选路时，先检索FIB表，如果找不到再检索路由表。 在大部分路由器中，RIB表现为路由表的形式， FIB则表现为高速缓存的形式，此在内容上是路由表的一个子集，是依靠路由表来生成的。 一般来说，FIB是进行高速查找而组织的数据结构（不是简单的把路由表中的内容复制出来，数据存储和检索方式等都不同于路由表的组成像是）。 RIB就一个字：全，知道到所有的地方怎么走，但是速度慢。FIB就一个字：快，只知道常走的路怎么走，速度快。 如果是分布式设备，通常FIB分布在LPU上，由LPU上的CPU实现快速选路，如果在LPU找不到路，才上到MPU处理，这里的RIB保存了最全的路由信息，可以提供不常用的选路结果。 ARP表和FDB表的区别： ARP表：IP和MAC的对应关系； FDB表：MAC+VLAN和PORT的对应关系； 两个最大的区别在于ARP是三层转发，FDB是用于二层转发。也就是说，就算两个设备不在一个网段或者压根没配IP，只要两者之间的链路层是连通的，就可以通过FDB表进行数据的转发！FDB表的最主要的作用就是在于交换机二层选路，试想，如果仅仅有ARP表，没有FDB表，就好像只知道地名和方位，而不知道经过哪条路才能到达目的地，设备是无法正常工作的。FDB表的作用就在于告诉设备从某个端口出去就可以到某个目的MAC。那么FDB表是怎么形成的呢？很简单，交换机会在收到数据帧时，提取数据帧中的源MAC、VLAN和接收数据帧的端口等组成FDB表的条目。当下次有到该VLAN中的该MAC的报文就直接从该端口丢出去就OK了。当然，FDB表和ARP表一样，都有一个老化时间。FDB表查看的方法该命令将显示一个学习到的MAC地址与关联端口的列表。各个条目都有一个相关的附于其上的老化计时器，因此转发条目可以在一定时间后刷新，以使MAC学习表更新到最新。【linux网桥】]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>网络,linux嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【linux嵌入式】]]></title>
    <url>%2Fnet_networkskill.html</url>
    <content type="text"><![CDATA[table { width: 100%}table th:nth-of-type(1) { width: 25%;}table th:nth-of-type(2) { width: 75%;} 学习资源知识结构 分类 链接 二层 【网络编程】【RIB表与FIB表、ARP表与FDB表】【网络编程】【邻居表】 三层 【网络编程】【RIB表与FIB表、ARP表与FDB表】【网络编程】【邻居表】]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Excel 技巧]]></title>
    <url>%2Fskill_excel.html</url>
    <content type="text"><![CDATA[单元格属性类Excel2016实现多级下拉联动]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>excel, 技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置debian虚拟机网卡]]></title>
    <url>%2Fdebian_config_int.html</url>
    <content type="text"><![CDATA[背景作为一名linux嵌入式网络工作者，平时办公时是window + linux结合, window 是办公平台，linux是工作和技术平台。一些操作在linux下面操作更为舒适，同时为了搭建一些测试场景，考虑创建一个linux虚拟机。安装完成debian后，网卡一直无法联网，下面给出debian（9.x）网卡的配置过程。 配置过程VMware 的网卡模式配置成桥接模式管理-&gt;虚拟机设置-&gt;网络适配器-&gt;桥接模式 配置debian网卡 打开网口配置文件内容如下vi /etc/network/interfaces12345678910111213# This file describes the network interfaces available on your system # and how to activate them. For more information, see interfaces(5). source /etc/network/interfaces.d/* # The loopback network interface auto lo iface lo inet loopback # The primary network interface allow-hotplug ens33 auto ens33 iface ens33 inet dhcp 里面共两个网口 lo 和 ens33。lo是个环回网口，我们不用管。配置ens33 网卡就可以, 该网口初始配置是dhcp模式，我们要做一些修改。 查看主机的ip地址 在pc的cmd窗口执行ipconfig123IPv4 地址 . . . . . . . . . . . . : 192.168.1.4子网掩码 . . . . . . . . . . . . : 255.255.255.0默认网关. . . . . . . . . . . . . : 192.168.1.1 可以看到本机分配的地址信息。 配置debian网卡信息根据主机信息配置网卡信息，具体如下。12345678910...# The primary network interface # allow-hotplug ens33 auto ens33 iface ens33 inet static address 192.168.1.5 netmask 255.255.255.0 network 192.168.1.0 broadcast 192.168.1.255 gateway 192.168.1.1 注：这里面我们将ens33网卡配置成静态IP地址。 重启网卡 1/etc/init.d/netwoking restart 网卡信息确认 1ip address 显示如下的网卡信息123456...2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:72:16:a7 brd ff:ff:ff:ff:ff:ff inet 192.168.1.5/24 brd 192.168.1.255 scope global ens33 valid_lft forever preferred_lft forever... 网卡试通 试通：百度 1ping www.baidu.com 试通：主机 –&gt; debian主机上面输入 1ping 192.168.1.5 //刚配置的网卡IP地址 试通：debian –&gt; 主机debian上面输入 1ping 192.168.1.4 //主机IP地址 注： 与网络不通，就需要视情况而定 debian和主机间地址不通，原因可能由于PC的防火墙拦截了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>网卡，虚拟机，debian</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试环境搭建]]></title>
    <url>%2Ftest_environment.html</url>
    <content type="text"><![CDATA[2019年5月26日配置网卡 debian 安装service 安装service123sudo apt-get install sysvinit-utils //service 安装在了/usr/sbin/service 位置vi ~/.bashrc //在.bashrc 中添加路径export PATH=$PATH:/usr/sbin/ source ~/.bashrc //生效修改内容 debian 搭建ftp sever安装ftp 2019年5月25日debian虚拟机 配置英文系统字体文件：/etc/default/locale内容：LANG=”en_US.UTF-8”LANGUAGE=”en_US:en”注意：配置完成后重启 安装VMware tools挂载磁盘工具mkdir /mnt/cdrommount /dev/cdrom /mnt/cdrom解压工具包tar zxpf /mnt/cdrom/VMwareTools-x.x.x-yyyy.tar.gz在这个过程中可能会有一些权限问题，可以将这个tar包复制到其它目录进行解压解压完成后会有一个目录cd vmware-tools-distribsudo ./vmware-install.pl执行过程中一直回车就行 配置网卡后补充 配置VMware 的滴滴声音找了很多中办法，就下面的这种办法有效：vi /etc/inputrc找到set bell-style none 将前面的＃去掉，之后重启系统即可解决声音问题完美解决办法：通过终端工具登录该服务器，使用起来更舒服。 解决桥接模式下虚拟机ping本机不通的问题 安装终端工具 安装cmder 2019年5月22日安装虚拟机 下载VMware 下载debian(9.x)镜像 安装debian(9.x)镜像]]></content>
      <categories>
        <category>历程</category>
      </categories>
      <tags>
        <tag>环境,测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高效工具]]></title>
    <url>%2Ftools.html</url>
    <content type="text"><![CDATA[window 工具 window 黑科技工具包含的工具：Everything,Wox,Fences,AutoHotKey,Total Commander,SpaceSniffer,Clover,Ditto, CCleaner,Listary文章中提到的工具，在自己办公过程中大部分都有在使用到，给自己也带来了很多的便利和效率。 git 工具github clone 特别慢问题解决 SSTap的模式设置为不代理中国IP 然后下载过程中使用https链接即可达到200k左右 chm 工具微软HTML帮助集，即编译的HTML帮助文件（英语：Microsoft Compiled HTML Help, CHM），是微软继承早先的WinHelp发展的一种文件格式，用来提供在线帮助，是一种应用较广泛的文件格式。因为CHM文件如一本书一样，可以提供内容目录、索引和搜索等功能，所以也常被用来制作电子书。近期有合并chm的需求，但从网上找了很多的方法，都不行。过程中接触到多个chm软件，一下以各个软件的。 HTML Help workshop这个软件是微软推出的制作chm的软件, 查看帮助文档后，可以制作出chm文档，但在合并文件后总是报错（HHC5013: Error: URL reference in the TOC cannot be resolved:***)，错误无法解决。 ABC Amber CHM Merger这个工具很好用，但是有以下的缺陷。 合并的chm不支持中文语言，导致合并后主题乱码 合并后没有所有窗口，原来的搜索窗口丢失注：在合并时需要指定hhc.exe的位置 RoboHTML找到了下面的指导文档，但时无法安装上面的工具，哎哎哎！心累。。。http://www.hypertexas.com/RHTutor/merger.htm linux 工具串口效率工具 autojump 银色搜索 -ag vim ctags 和 cscope cmder]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具, 效率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ftp协议]]></title>
    <url>%2Fftp.html</url>
    <content type="text"><![CDATA[简介文件传输协议（英语：File Transfer Protocol，缩写：FTP）是一个用于在计算机网络上在客户端和服务器之间进行文件传输的应用层协议。 协议所在位置应用层协议 说明ftp协议使用的是常见的C/S结构，默认使用20和21端口号进行传输。在传输过程中要使用两个通道：传输数据流控制通道和传输数据通道。ftp也分为主动模式和被动模式，主动模式要求客户端和服务器端同时打开并且监听一个端口以创建连接。在这种情况下，客户端由于安装了防火墙会产生一些问题。所以，创立了被动模式。被动模式只要求服务器端产生一个监听相应端口的进程，这样就可以绕过客户端安装了防火墙的问题。下图是主动和被动模式协议流程。小结 区别主动模式和被动模式的方法看数据链接过程是由哪端发起: Server端发起即主动模式，Server端被动接收即被动模式。 在主动模式中才会用到知名端口20, 在被动模式下server的数据通道端口是随机的。 相关RFC1.RFC959:官方协议规范2.RFC1579:启用防火墙FTP(被动模式)3.RFC2228:安全扩展4.RFC2428:增加对IPv6的支持 参考资料 维基百科:文件传输协议 FTP主动模式和被动模式 FTP主动模式和被动模式的区别]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ftp,主动模式,被动模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知名端口号]]></title>
    <url>%2Ftcp-ip-port.html</url>
    <content type="text"><![CDATA[简介计算机之间依照互联网传输层TCP/IP协议的协议通信，不同的协议都对应不同的端口。并且，利用数据报文的UDP也不一定和TCP采用相同的端口号码。以下为两种通信协议的端口列表链接。知名端口，顾名思义，大家约定俗成的共识的使用的端口号。 知名端口号 端口 描述 状态 0/TCP,UDP 保留端口；不使用（若发送过程不准备接受回复消息，则可以作为源端口） 官方 1/TCP,UDP TCPMUX（传输控制协议端口服务多路开关选择器） 官方 5/TCP,UDP RJE（远程作业登录） 官方 7/TCP,UDP Echo（回显）协议 官方 9/UDP DISCARD（丢弃）协议 官方 9/TCP,UDP 网络唤醒 非官方 11/TCP,UDP SYSTAT协议 官方 13/TCP,UDP DAYTIME协议 官方 15/TCP,UDP NETSTAT协议 官方 17/TCP,UDP QOTD（Quote of the Day，每日引用）协议 官方 18/TCP,UDP 消息发送协议 官方 19/TCP,UDP CHARGEN（字符发生器）协议 官方 20/TCP,UDP 文件传输协议 - 默认数据端口(FTP协议) 官方 21/TCP,UDP 文件传输协议 - 控制端口(FTP协议) 官方 22/TCP,UDP SSH（Secure Shell） - 远程登录协议，用于安全登录文件传输（SCP，SFTP）及端口重新定向 官方 23/TCP,UDP Telnet终端仿真协议 - 未加密文本通信 官方 25/TCP,UDP SMTP（简单邮件传输协议） - 用于邮件服务器间的电子邮件传递 官方 26/TCP,UDP RSFTP - 一个简单的类似FTP的协议 非官方 35/TCP,UDP 任意的私有打印机服务端口 非官方 37/TCP,UDP TIME时间协议 官方 39/TCP,UDP Resource Location Protocol（资源定位协议） 官方 41/TCP,UDP 图形 官方 42/TCP,UDP Host Name Server 官方 42/TCP,UDP WINS（WINS主机名服务） 非官方 43/TCP WHOIS协议 官方 49/TCP,UDP TACACS登录主机协议 官方 53/TCP,UDP DNS（域名服务系统） 官方 56/TCP,UDP 远程访问协议 官方 57/TCP MTP，邮件传输协议 官方 67/UDP BOOTP（BootStrap协议）服务；同时用于动态主机设置协议(DHCP) 官方 68/UDP BOOTP客户端；同时用于动态主机设定协议 官方 69/UDP 小型文件传输协议（小型文件传输协议） 官方 70/TCP Gopher 官方 79/TCP 手指协议 官方 80/TCP 超文本传输协议（超文本传输协议）- 用于传输网页.即常见的HTTP协议 官方 81/TCP XB Browser - Tor 非官方 82/UDP XB Browser - 控制端口 非官方 88/TCP Kerberos - 认证代理 官方 101/TCP 主机名 官方 102/TCP ISO-TSAP协议 官方 107/TCP 远程Telnet协议 官方 109/TCP POP (Post Office Protocol)，“邮局协议”，第2版 官方 110/TCP 邮局协议，“邮局协议”，第3版 - 用于接收电子邮件 官方 111/TCP,UDP Sun远程过程调用协议 官方 113/TCP Ident - 旧的服务器身份识别系统，仍然被IRC服务器用来认证它的用户 官方 115/TCP SFTP，简单文件传输协议 官方 117/TCP UNIX间复制协议（Unix to Unix Copy Protocol，UUCP）的路径确定服务 官方 118/TCP,UDP SQL服务 官方 119/TCP 网络新闻传输协议 - 用来收取新闻组的消息 官方 123/UDP NTP（Network Time Protocol） - 用于时间同步 官方 135/TCP,UDP 分布式运算环境（Distributed Computing Environment，DCE）终端解决方案及定位服务 官方 135/TCP,UDP 微软终端映射器（End Point Mapper，EPMAP） 官方 137/TCP,UDP NetBIOS NetBIOS 名称服务 官方 138/TCP,UDP NetBIOS NetBIOS 数据报文服务 官方 139/TCP,UDP NetBIOS NetBIOS 会话服务 官方 143/TCP,UDP 因特网信息访问协议（Internet信息访问协议 4） - 用于检索 电子邮件s 官方 152/TCP,UDP BFTP, 后台文件传输程序 官方 153/TCP,UDP 简单网关监控协议（Simple Gateway Monitoring Protocol，SGMP） 官方 156/TCP,UDP SQL服务 官方 158/TCP,UDP DMSP, 分布式邮件服务协议 非官方 161/TCP,UDP 简单网络管理协议 (简单网络管理协议) 官方 162/TCP,UDP SNMP协议的TRAP操作 官方 170/TCP 打印服务 官方 179/TCP 边界网关协议 (边界网关协议) 官方 194/TCP IRC（互联网中继聊天） 官方 201/TCP,UDP AppleTalk 路由维护 官方 209/TCP,UDP Quick Mail 传输协议 官方 213/TCP,UDP IPX，互联网分组交换协议 官方 218/TCP,UDP MPP，信息发布协议 官方 220/TCP,UDP 因特网信息访问协议，交互邮件访问协议第3版 官方 259/TCP,UDP ESRO, Efficient Short Remote Operations 官方 264/TCP,UDP BGMP，边界网关多播协议 官方 308/TCP Novastor 在线备份 官方 311/TCP Apple 服务器管理员工具、工作组管理 官方 318/TCP,UDP TSP，时间戳协议 官方 323/TCP,UDP IMMP, Internet消息映射协议 官方 383/TCP,UDP HP OpenView HTTPs 代理程序 官方 366/TCP,UDP SMTP, 简单邮件传送协议. ODMR,按需邮件传递 官方 369/TCP,UDP Rpc2 端口映射 官方 371/TCP,UDP ClearCase 负载平衡 官方 384/TCP,UDP 一个远程网络服务器系统 官方 387/TCP,UDP AURP, AppleTalk 升级用路由协议 官方 389/TCP,UDP 轻型目录访问协议 LDAP 官方 401/TCP,UDP 不间断电源，不间断电源供应系统 官方 411/TCP Direct Connect Hub 端口 非官方 412/TCP Direct Connect 客户端—客户端 端口 非官方 427/TCP,UDP 服务定位协议 (位置服务协议) 官方 443/TCP 超文本传输安全协议 - 超文本传输协议 over TLS/SSL（加密传输）,HTTPS协议 官方 444/TCP,UDP SNPP，简单网络分页协议 官方 445/TCP Microsoft-DS (Active Directory，Windows 共享, 震荡波蠕虫，Agobot, Zobotworm) 官方 445/UDP Microsoft-DS 服务器消息块 SMB文件共享 官方 464/TCP,UDP Kerberos 更改/设定密码 官方 465/TCP Cisco 专用协议 官方 465/TCP 传输层安全性协议加密的简单邮件传输协议 非官方 475/TCP tcpnethaspsrv（Hasp 服务, TCP/IP 版本） 官方 497/TCP dantz 备份服务 官方 500/TCP,UDP 网络安全关系与密钥管理协议，IKE-Internet 密钥交换 官方 502/TCP,UDP Modbus 协议 官方 512/TCP exec, 远程进程执行 官方 512/UDP comsat 和 biff 命令：用于电子邮件系统 官方 513/TCP login，登录命令 官方 513/UDP Who命令，查看当前登录计算机的用户 官方 514/TCP 远程外壳 protocol - 用于在远程计算机上执行非交互式命令，并查看返回结果 官方 514/UDP Syslog 协议 - 用于系统登录 官方 515/TCP Line Printer Daemon protocol - 用于 LPD 打印机服务器 官方 517/UDP Talk 官方 518/UDP NTalk 官方 520/TCP efs 官方 520/UDP Routing - 路由信息协议 官方 513/UDP 路由器 官方 524/TCP,UDP NetWare核心协议（NetWare 核心协议）用于一系列功能，例如访问NetWare主服务器资源、同步时间等 官方 525/UDP Timed，时间服务 官方 530/TCP,UDP 远程过程调用 官方 531/TCP,UDP AOL 即时通信软件, IRC 非官方 532/TCP netnews 官方 533/UDP netwall,用于紧急广播 官方 540/TCP UUCP (Unix-to-Unix 复制协议) 官方 542/TCP,UDP 商业 (Commerce Applications) 官方 543/TCP klogin, Kerberos登陆 官方 544/TCP kshell, Kerberos 远程shell 官方 546/TCP,UDP DHCPv6客户端 官方 547/TCP,UDP DHCPv6服务器 官方 548/TCP 通过传输控制协议（TCP）的 Appletalk 文件编制协议（AFP(苹果归档协议)) 官方 550/UDP new-rwho, new-who 官方 554/TCP,UDP 即时流协议 即时流协定 官方 556/TCP Brunhoff 的远程文件系统（RFS） 官方 560/UDP rmonitor, Remote Monitor 官方 561/UDP monitor 官方 563/TCP,UDP 网络新闻传输协议 通过安全套接字层的网络新闻传输协议（NNTPS） 官方 587/TCP 邮件消息提交（简单邮件传输协议，RFC 2476） 官方 591/TCP FileMaker 6.0（及之后版本）网络共享（HTTP的替代，见80端口） 官方 593/TCP,UDP HTTP RPC Ep Map（RPC over HTTP, often used by Distributed COM services and Microsoft Exchange Server） 官方 604/TCP TUNNEL 官方 631/TCP,UDP 互联网打印协议 636/TCP,UDP LDAP over SSL（加密传输，也被称为LDAPS） 官方 639/TCP,UDP MSDP, 组播源发现协议 官方 646/TCP,UDP LDP, 标签分发协议 官方 647/TCP DHCP故障转移协议 官方 648/TCP RRP( Registry Registrar Protocol)，注册表注册协议 官方 652/TCP DTCP(Dynamic Tunnel Configuration Protocol)，动态主机设置协议 官方 654/UDP AODV(Ad hoc On-Demand Distance Vector)，无线自组网按需平面距离向量路由协议 官方 665/TCP sun-dr, Remote Dynamic Reconfiguration 非官方 666/UDP 毁灭战士，计算机平台上的一系列第一人称射击游戏。 官方 674/TCP ACAP(Application Configuration Access Protocol)，应用配置访问协议 官方 691/TCP MS Exchange Routing 官方 692/TCP Hyperwave-ISP 694/UDP 用于带有高可用性的聚类的心跳服务 非官方 695/TCP IEEE-MMS-SSL 698/UDP OLSR(Optimized Link State Routing)，优化链路状态路由协议 699/TCP Access Network 700/TCP EPP, 可扩展供应协议 701/TCP LMP,链路管理协议 702/TCP IRIS over BEEP 706/TCP SILC, Secure Internet Live Conferencing 711/TCP TDP, 标签分发协议 712/TCP TBRPF, Topology Broadcast based on Reverse-Path Forwarding 720/TCP SMQP, Simple Message Queue Protocol 749/TCP, UDP kerberos-adm, Kerberos administration 750/UDP Kerberos version IV 782/TCP Conserver serial-console management server 829/TCP 证书管理协议（CMP）[2] 860/TCP ISCSI，Internet小型计算机系统接口 873/TCP Rsync ，文件同步协议 官方 901/TCP Samba 网络管理工具(SWAT) 非官方 902 VMware服务器控制台[3] 非官方 904 VMware服务器替代（如果902端口已被占用） 非官方 911/TCP Network Console on Acid（NCA） - local tty redirection over OpenSSH 981/TCP Check Point Remote HTTPS management for firewall devices running embedded Checkpoint Firewall-1 software 非官方 989/TCP,UDP FTP Protocol (data) over TLS/SSL 官方 990/TCP,UDP FTP Protocol (control) over TLS/SSL 官方 991/TCP,UDP NAS (Netnews Admin System) 992/TCP,UDP 基于TLS / SSL的Telnet协议 官方 993/TCP 基于 传输层安全性协议的因特网信息访问协议 (加密传输) 官方 995/TCP 基于 传输层安全性协议的邮局协议 (加密传输) 官方 端口 描述 状态 1025/tcp NFS-or-IIS 非官方 1026/tcp 通常用于微软Distributed COM服务器 非官方 1029/tcp 通常用于微软Distributed COM服务器 非官方 1058/tcp nim IBM AIX 官方 1059/tcp nimreg 官方 1080/tcp SOCKS代理 官方 1099/tcp,udp Java远程方法调用 Registry 官方 1109/tcp Kerberos POP 1140/tcp AutoNOC 官方 1167/udp phone, conference calling 1176/tcp Perceptive Automation Indigo home control server 官方 1182/tcp,udp AcceleNet 官方 1194/udp OpenVPN 官方 1198/tcp,udp The cajo project Free dynamic transparent distributed computing in Java 官方 1200/udp Steam 官方 1214/tcp Kazaa 官方 1223/tcp,udp TGP: “TrulyGlobal Protocol” aka “The Gur Protocol” 官方 1241/tcp,udp Nessus Security Scanner 官方 1248/tcp NSClient/NSClient++/NC_Net (Nagios) 非官方 1270/tcp,udp Microsoft Operations Manager 2005 agent (MOM 2005) 官方 1311/tcp Dell Open Manage Https Port 非官方 1313/tcp Xbiim (Canvii server) Port 非官方 1337/tcp WASTE Encrypted File Sharing Program 非官方 1352/tcp IBM IBM Lotus Notes/Domino RPC 官方 1387/tcp,udp Computer Aided Design Software Inc LM (cadsi-lm ) 官方 1414/tcp IBM MQSeries 官方 1431/tcp RGTP 官方 1433/tcp,udp Microsoft SQL 数据库系统 官方 1434/tcp,udp Microsoft SQL 活动监视器 官方 1494/tcp 思杰系统 ICA Client 官方 1512/tcp,udp WINS 1521/tcp nCube License Manager 官方 1521/tcp Oracle数据库 default listener, in future releases official port 2483 非官方 1524/tcp,udp ingreslock, ingres 官方 1526/tcp Oracle数据库 common alternative for listener 非官方 1533/tcp IBM Lotus Sametime IM - Virtual Places Chat 官方 1547/tcp,udp Laplink 官方 1550 Gadu-Gadu (Direct Client-to-Client) 非官方 1581/udp MIL STD 2045-47001 VMF 官方 1589/udp Cisco VQP (VLAN Query Protocol) / VMPS 非官方 1627 iSketch 非官方 1677/tcp Novell GroupWise clients in client/server access mode 1701/udp 第二层隧道协议, Layer 2 Tunnelling protocol 1716/tcp 美国陆军系列 MMORPG Default Game Port 官方 1723/tcp,udp Microsoft 点对点隧道协议 VPN 官方 1725/udp Valve Steam Client 非官方 1755/tcp,udp MMS (协议) (MMS, ms-streaming) 官方 1761/tcp,udp cft-0 官方 1761/tcp Novell Zenworks Remote Control utility 非官方 1762-1768/tcp,udp cft-1 to cft-7 官方 1812/udp radius, 远端用户拨入验证服务 authentication protocol 1813/udp radacct, 远端用户拨入验证服务 accounting protocol 1863/tcp Windows Live Messenger, MSN 官方 1900/udp Microsoft 简单服务发现协议 Enables discovery of UPnP devices 官方 1935/tcp 实时消息协议 (RTMP) raw protocol 官方 1970/tcp,udp Danware Data NetOp Remote Control 官方 1971/tcp,udp Danware Data NetOp School 官方 1972/tcp,udp InterSystems Caché 官方 1975-77/udp Cisco TCO (Documentation) 官方 1984/tcp Big Brother - network monitoring tool 官方 1985/udp 热备份路由器协议 官方 1994/TCP STUN-SDLC protocol for tunneling 1998/tcp Cisco X.25 service (XOT) 2000/tcp,udp Cisco SCCP (Skinny) 官方 2002/tcp Cisco Secure Access Control Server (ACS) for Windows 非官方 2030 甲骨文公司 Services for Microsoft Transaction Server 非官方 2031/tcp,udp mobrien-chat - Mike O’Brien &#109;&#x69;&#x6b;&#x65;&#64;&#109;&#111;&#x62;&#x72;&#x69;&#101;&#110;&#x2e;&#x63;&#111;&#109; November 2004 官方 2049/udp nfs, NFS Server 官方 2049/udp shilp 官方 2053/tcp knetd, Kerberos de-multiplexor 2056/udp 文明IV multiplayer 非官方 2073/tcp,udp DataReel Database 官方 2074/tcp,udp Vertel VMF SA (i.e. App.. SpeakFreely) 官方 2082/tcp Infowave Mobility Server 官方 2082/tcp CPanel, default port 非官方 2083/tcp Secure Radius Service (radsec) 官方 2083/tcp CPanel default SSL port 非官方 2086/tcp GNUnet 官方 2086/tcp CPanel default port 非官方 2087/tcp CPanel default SSL port 非官方 2095/tcp CPanel default webmail port 非官方 2096/tcp CPanel default SSL webmail port 非官方 2161/tcp 问号-APC Agent 官方 2181/tcp,udp EForward-document transport system 官方 2200/tcp Tuxanci game server 非官方 2219/tcp,udp NetIQ NCAP Protocol 官方 2220/tcp,udp NetIQ End2End 官方 2222/tcp DirectAdmin’s default port 非官方 2222/udp Microsoft Office OS X antipiracy network monitor [1] 非官方 2301/tcp HP System Management Redirect to port 2381 非官方 2302/udp 武装突袭 multiplayer (default for game) 非官方 2302/udp 最后一战：战斗进化 multiplayer 非官方 2303/udp 武装突袭 multiplayer (default for server reporting) (default port for game +1) 非官方 2305/udp 武装突袭 multiplayer (default for VoN) (default port for game +3) 非官方 2369/tcp Default port for BMC软件公司 CONTROL-M/Server - Configuration Agent port number - though often changed during installation 非官方 2370/tcp Default port for BMC软件公司 CONTROL-M/Server - Port utilized to allow the CONTROL-M/Enterprise Manager to connect to the CONTROL-M/Server - though often changed during installation 非官方 2381/tcp HP Insight Manager default port for webserver 非官方 2404/tcp IEC 60870-5-104 官方 2427/udp Cisco MGCP 官方 2447/tcp,udp ovwdb - OpenView Network Node Manager (NNM) daemon 官方 2483/tcp,udp Oracle数据库 listening port for unsecure client connections to the listener, replaces port 1521 官方 2484/tcp,udp Oracle数据库 listening port for SSL client connections to the listener 官方 2546/tcp,udp Vytal Vault - Data Protection Services 非官方 2593/tcp,udp RunUO - 网络创世纪 server 非官方 2598/tcp new ICA - when Session Reliability is enabled, TCP port 2598 replaces port 1494 非官方 2612/tcp,udp QPasa from MQSoftware 官方 2710/tcp XBT Bittorrent Tracker 非官方 2710/udp XBT Bittorrent Tracker experimental UDP tracker extension 非官方 2710/tcp Knuddels.de 非官方 2735/tcp,udp NetIQ Monitor Console 官方 2809/tcp corbaloc:iiop URL, per the CORBA 3.0.3 specification.Also used by IBM IBM WebSphere Application Server Node Agent 官方 2809/udp corbaloc:iiop URL, per the CORBA 3.0.3 specification. 官方 2944/udp Megaco Text H.248 非官方 2945/udp Megaco Binary (ASN.1) H.248 非官方 2948/tcp,udp 无线应用协议-push 彩信 (MMS) 官方 2949/tcp,udp 无线应用协议-pushsecure 彩信 (MMS) 官方 2967/tcp Symantec AntiVirus Corporate Edition 非官方 3000/tcp Miralix License server 非官方 3000/udp Distributed Interactive Simulation (DIS), modifiable default port 非官方 3000/tcp Puma Web Server 非官方 3001/tcp Miralix Phone Monitor 非官方 3002/tcp Miralix CSTA 非官方 3003/tcp Miralix GreenBox API 非官方 3004/tcp Miralix InfoLink 非官方 3006/tcp Miralix SMS Client Connector 非官方 3007/tcp Miralix OM Server 非官方 3025/tcp netpd.org 非官方 3050/tcp,udp gds_db (Interbase/Firebird) 官方 3074/tcp,udp Xbox Live 官方 3128/tcp 超文本传输协议 used by Web缓存s and the default port for the Squid (软件) 官方 3260/tcp ISCSI target 官方 3268/tcp msft-gc, Microsoft Global Catalog (轻型目录访问协议 service which contains data from Active Directory forests) 官方 3269/tcp msft-gc-ssl, Microsoft Global Catalog over SSL (similar to port 3268, 轻型目录访问协议 over 传输层安全性协议 version) 官方 3300/tcp TripleA game server 非官方 3305/tcp,udp ODETTE-FTP 官方 3306/tcp,udp MySQL数据库系统 官方 3333/tcp Network Caller ID server 非官方 3386/tcp,udp GTP’ 3GPP GSM/通用移动通讯系统 CDR logging protocol 官方 3389/tcp 远程桌面协议（RDP） 官方 3396/tcp Novell NDPS Printer Agent 官方 3689/tcp DAAP Digital Audio Access Protocol used by 苹果公司 ITunes 官方 3690/tcp Subversion version control system 官方 3702/tcp,udp Web Services Dynamic Discovery (WS-Discovery), used by various components of Windows Vista 官方 3724/tcp 魔兽世界 Online gaming MMORPG 官方 3784/tcp,udp Ventrilo VoIP program used by Ventrilo 官方 3785/udp Ventrilo VoIP program used by Ventrilo 官方 3868 tcp,udp Diameter base protocol 官方 3872/tcp Oracle Management Remote Agent 非官方 3899/tcp Remote Administrator 非官方 3900/tcp Unidata UDT OS udt_os 官方 3945/tcp Emcads server service port, a Giritech product used by G/On 官方 4000/tcp 暗黑破坏神II game NoMachine Network Server (nxd) 非官方 4007/tcp PrintBuzzer printer monitoring socket server 非官方 4089/tcp,udp OpenCORE Remote Control Service 官方 4093/tcp,udp PxPlus Client server interface ProvideX 官方 4096/udp Bridge-Relay Element ASCOM 官方 4100 WatchGuard Authentication Applet - default port 非官方 4111/tcp,udp Xgrid 官方 4111/tcp SharePoint - 默认管理端口 非官方 4226/tcp,udp Aleph One (computer game) 非官方 4224/tcp 思科系统 CDP Cisco discovery Protocol 非官方 4569/udp Inter-Asterisk eXchange 非官方 4662/tcp OrbitNet Message Service 官方 4662/tcp 通常用于EMule 非官方 4664/tcp Google桌面搜索 非官方 4672/udp EMule - 常用端口 非官方 4894/tcp LysKOM Protocol A 官方 4899/tcp Radmin 远程控制工具 官方 5000/tcp commplex-main 官方 5000/tcp UPnP - Windows network device interoperability 非官方 5000/tcp,udp VTun - 虚拟专用网 软件 非官方 5001/tcp,udp Iperf (Tool for measuring TCP and UDP bandwidth performance) 非官方 5001/tcp Slingbox及Slingplayer 非官方 5003/tcp FileMaker Filemaker Pro 官方 5004/udp 实时传输协议实时传输协议 官方 5005/udp 实时传输协议实时传输协议 官方 5031/tcp,udp AVM CAPI-over-TCP (综合业务数字网 over 以太网 tunneling) 非官方 5050/tcp Yahoo! Messenger 官方 5051/tcp ita-agent Symantec Intruder Alert 官方 5060/tcp,udp 会话发起协议 (SIP) 官方 5061/tcp 会话发起协议 (SIP) over 传输层安全性协议 (TLS) 官方 5093/udp SPSS License Administrator (SPSS) 官方 5104/tcp IBM NetCOOL / IMPACT HTTP Service 非官方 5106/tcp A-Talk Common connection 非官方 5107/tcp A-Talk 远程服务器连接 非官方 5110/tcp ProRat Server 非官方 5121/tcp 无冬之夜 官方 5176/tcp ConsoleWorks default UI interface 非官方 5190/tcp ICQ and AIM (应用程序) 官方 5222/tcp XMPP/Jabber - client connection 官方 5223/tcp XMPP/Jabber - default port for SSL Client Connection 非官方 5269/tcp XMPP/Jabber - server connection 官方 5351/tcp,udp NAT Port Mapping Protocol - client-requested configuration for inbound connections through 网络地址转换 官方 5353/udp mDNS - multicastDNS 5402/tcp,udp StarBurst AutoCast MFTP 官方 5405/tcp,udp NetSupport 官方 5421/tcp,udp Net Support 2 官方 5432/tcp PostgreSQL database system 官方 5445/udp 思科系统 Vidéo VT Advantage 非官方 5495/tcp Applix TM1 Admin server 非官方 5498/tcp Hotline tracker server connection 非官方 5499/udp Hotline tracker server discovery 非官方 5500/tcp VNC remote desktop protocol - for incoming listening viewer, Hotline control connection 非官方 5501/tcp Hotline file transfer connection 非官方 5517/tcp Setiqueue Proxy server client for SETI@home project 非官方 5555/tcp Freeciv multiplay port for versions up to 2.0, 惠普 Data Protector, 会话通告协议 非官方 5556/tcp Freeciv multiplay port 官方 5631/tcp 赛门铁克 pcAnywhere 官方 5632/udp 赛门铁克 pcAnywhere 官方 5666/tcp NRPE (Nagios) 非官方 5667/tcp NSCA (Nagios) 非官方 5800/tcp VNC remote desktop protocol - for use over 超文本传输协议 非官方 5814/tcp,udp 惠普 Support Automation (HP OpenView Self-Healing Services) 官方 5900/tcp VNC remote desktop protocol (used by ARD) 官方 6000/tcp X窗口系统 - used between an X client and server over the network 官方 6001/udp X窗口系统 - used between an X client and server over the network 官方 6005/tcp Default port for BMC软件公司 CONTROL-M/Server - Socket Port number used for communication between CONTROL-M processes - though often changed during installation 非官方 6050/tcp Brightstor Arcserve Backup 非官方 6051/tcp Brightstor Arcserve Backup 非官方 6100/tcp Vizrt System 非官方 6110/tcp,udp softcm HP SoftBench CM 官方 6111/tcp,udp spc HP SoftBench Sub-Process Control 官方 6112/tcp dtspcd - a network daemon that accepts requests from clients to execute commands and launch applications remotely 官方 6112/tcp 暴雪娱乐’s 暴雪战网 gaming service, ArenaNet gaming service 官方 6129/tcp Dameware Remote Control 非官方 6257/udp WinMX （参见6699端口） 非官方 6346/tcp,udp gnutella-svc (FrostWire, LimeWire, Bearshare, etc.) 官方 6347/tcp,udp gnutella-rtr 官方 6379/tcp Redis - Redis 非官方 6444/tcp,udp Oracle Grid Engine - Qmaster Service 官方 6445/tcp,udp Oracle Grid Engine - Execution Service 官方 6502/tcp,udp Danware Data NetOp Remote Control 非官方 6522/tcp Gobby (and other libobby-based software) 非官方 6543/udp Jetnet - default port that the Paradigm Research &amp; Development Jetnet protocol communicates on 非官方 6566/tcp SANE (Scanner Access Now Easy) - SANE network scanner daemon 非官方 6600/tcp Music Playing Daemon (MPD) 非官方 6619/tcp,udp ODETTE-FTP over TLS/SSL 官方 6665-6669/tcp IRC 官方 6679/tcp IRC SSL （安全互联网中继聊天） - 通常使用的端口 非官方 6697/tcp IRC SSL （安全互联网中继聊天） - 通常使用的端口 非官方 6699/tcp WinMX （参见6257端口） 非官方 6881-6999/tcp,udp BitTorrent 通常使用的端口 非官方 6891-6900/tcp,udp Windows Live Messenger （文件传输） 官方 6901/tcp,udp Windows Live Messenger （语音） 官方 6969/tcp acmsoda 官方 6969/tcp BitTorrent tracker port 非官方 7000/tcp Default port for Azureus’s built in 超文本传输安全协议 BitTorrent tracker 非官方 7001/tcp Default port for BEA WebLogic Server’s 超文本传输协议 server - though often changed during installation 非官方 7002/tcp Default port for BEA WebLogic Server’s 超文本传输安全协议 server - though often changed during installation 非官方 7005/tcp,udp Default port for BMC软件公司 CONTROL-M/Server and CONTROL-M/Agent’s - Agent to Server port though often changed during installation 非官方 7006/tcp,udp Default port for BMC软件公司 CONTROL-M/Server and CONTROL-M/Agent’s - Server to Agent port though often changed during installation 非官方 7010/tcp Default port for Cisco AON AMC (AON Management Console) [2] 非官方 7025/tcp Zimbra - lmtp [mailbox] - local mail delivery 非官方 7047/tcp Zimbra - conversion server 非官方 7171/tcp Tibia 7306/tcp Zimbra - mysql [mailbox] 非官方 7307/tcp Zimbra - mysql [logger] - logger 非官方 7312/udp Sibelius License Server port 非官方 7670/tcp BrettSpielWelt BSW Boardgame Portal 非官方 7777/tcp Default port used by Windows backdoor program tini.exe 非官方 8000/tcp iRDMI - often mistakenly used instead of port 8080 (The Internet Assigned Numbers Authority (iana.org) officially lists this port for iRDMI protocol) 官方 8000/tcp Common port used for internet radio streams such as those using SHOUTcast 非官方 8002/tcp Cisco Systems Unified Call Manager Intercluster Port 8008/tcp 超文本传输协议 替代端口 官方 8008/tcp IBM HTTP Server 默认管理端口 非官方 8009/tcp 阿帕契族 JServ 协议 v13 (ajp13) 例如：Apache mod_jk Tomcat会使用。 非官方 8010/tcp XMPP/Jabber 文件传输 非官方 8074/tcp Gadu-Gadu 非官方 8080/tcp 超文本传输协议 替代端口 （http_alt） - commonly used for 代理服务器 and caching server, or for running a web server as a non-Root user 官方 8080/tcp Apache Tomcat 非官方 8086/tcp HELM Web Host Automation Windows Control Panel 非官方 8086/tcp Kaspersky AV Control Center TCP Port 非官方 8087/tcp Hosting Accelerator Control Panel 非官方 8087/udp Kaspersky AV Control Center UDP Port 非官方 8087/tcp 英迈 控制面板 非官方 8090/tcp Another 超文本传输协议 Alternate (http_alt_alt) - used as an alternative to port 8080 非官方 8118/tcp Privoxy web proxy - advertisements-filtering web proxy 官方 8123/tcp Dynmap[4]默认网页端口号(Minecraft在线地图) 非官方 8200/tcp GoToMyPC 非官方 8220/tcp Bloomberg 非官方 8222 VMware服务器管理用户界面(不安全网络界面)[5]。参见 8333端口 非官方 8291/tcp Winbox - Default port on a MikroTik RouterOS for a Windows application used to administer MikroTik RouterOS 非官方 8294/tcp Bloomberg 非官方 8333 VMware 服务器管理用户界面（安全网络界面）[6]。参见8222端口 非官方 8400 Commvault Unified Data Management 官方 8443/tcp 英迈 Control Panel 非官方 8500/tcp Adobe ColdFusion Macromedia/Adobe ColdFusion default Webserver port 非官方 8501/udp 毁灭公爵3D - Default Online Port 官方 8767/udp TeamSpeak - Default UDP Port 非官方 8880 IBM WebSphere Application Server 简单对象访问协议 Connector port 8881/tcp Atlasz Informatics Research Ltd Secure Application Server 非官方 8882/tcp Atlasz Informatics Research Ltd Secure Application Server 非官方 8888/tcp,udp NewsEDGE server 官方 8888/tcp Sun Answerbook 网页服务器 server (deprecated by docs.sun.com) 非官方 8888/tcp GNUmp3d HTTP music streaming and web interface port 非官方 8888/tcp 英雄大作战 Network Game Server 非官方 9000/tcp Buffalo LinkSystem web access 非官方 9000/tcp DBGp 非官方 9000/udp UDPCast 非官方 9000 PHP - php-fpm 非官方 9001 cisco-xremote router configuration 非官方 9001 Tor network default port 非官方 9001/tcp DBGp Proxy 非官方 9002 Default ElasticSearch port 9009/tcp,udp Pichat Server - Peer to peer chat software 官方 9043/tcp IBM WebSphere Application Server Administration Console secure port 9060/tcp IBM WebSphere Application Server Administration Console 9100/tcp Jetdirect HP Print Services 官方 9110/udp SSMP Message protocol 非官方 9101 Bacula Director 官方 9102 Bacula File Daemon 官方 9103 Bacula Storage Daemon 官方 9119/TCP,UDP Mxit Instant Messenger 官方 9535/tcp man, Remote Man Server 9535 mngsuite - Management Suite Remote Control 官方 9800/tcp,udp 基于Web的分布式编写和版本控制 Source Port 官方 9800 WebCT e-learning portal 非官方 9999 Hydranode - edonkey2000 telnet control port 非官方 9999 Urchin Web Analytics 非官方 10000 Webmin - web based Linux admin tool 非官方 10000 BackupExec 非官方 10008 Octopus Multiplexer - CROMP protocol primary port, hoople.org 官方 10017 AIX,NeXT, HPUX - rexd daemon control port 非官方 10024/tcp Zimbra - smtp [mta] - to amavis from postfix 非官方 10025/tcp Ximbra - smtp [mta] - back to postfix from amavis 非官方 10050/tcp Zabbix-Agent 10051/tcp Zabbix-Server 10113/tcp,udp NetIQ Endpoint 官方 10114/tcp,udp NetIQ Qcheck 官方 10115/tcp,udp NetIQ Endpoint 官方 10116/tcp,udp NetIQ VoIP Assessor 官方 10480 SWAT 4 Dedicated Server 非官方 11211 Memcached 非官方 11235 Savage:Battle for Newerth Server Hosting 非官方 11294 Blood Quest Online Server 非官方 11371 PGP HTTP Keyserver 官方 11576 IPStor Server management communication 非官方 12035/udp Linden Lab viewer to sim 非官方 12345 NetBus - remote administration tool (often 特洛伊木马 (计算机)). Also used by NetBuster. Little Fighter 2 (TCP). 非官方 12975/tcp LogMeIn Hamachi (VPN tunnel software;also port 32976) 13000-13050/udp Linden Lab viewer to sim 非官方 13720/tcp 赛门铁克 NetBackup - bprd (formerly VERITAS) 13721/tcp 赛门铁克 NetBackup - bpdbm (formerly VERITAS) 13724/tcp 赛门铁克 Network Utility - vnet (formerly VERITAS) 13782/tcp 赛门铁克 NetBackup - bpcd (formerly VERITAS) 13783/tcp 赛门铁克 VOPIED protocol (formerly VERITAS) 14567/udp 战地风云1942 and mods 非官方 15000/tcp Bounce (网络) 非官方 15000/tcp 韦诺之战 15567/udp 战地风云：越南 and mods 非官方 15345/udp XPilot 官方 16000/tcp Bounce (网络) 非官方 16080/tcp MacOS Server performance cache for 超文本传输协议[7] 非官方 16384/udp Iron Mountain Digital - online backup 非官方 16567/udp 战地2 and mods 非官方 17788/udp PPS网络电视 非官方 19132/tcp Minecraft基岩版默认服务器端口号 非官方 19226/tcp 熊猫 (消歧义) AdminSecure Communication Agent 非官方 19638/tcp Ensim Control Panel 非官方 19813/tcp 4D database Client Server Communication 非官方 20000 Usermin - 基于网络的用户工具 官方 20720/tcp Symantec i3 Web GUI server 非官方 22347/tcp,udp WibuKey - default port for WibuKey Network Server of WIBU-SYSTEMS AG 官方 22350/tcp,udp CodeMeter - default port for CodeMeter Server of WIBU-SYSTEMS AG 官方 24554/tcp,udp binkp - FidoNet mail transfers over TCP/IP协议族 官方 24800 Synergy：keyboard/mouse sharing software 非官方 24842 StepMania：Online: 劲爆热舞 Simulator 非官方 25565/tcp Minecraft默认服务器端口号 非官方 25999/tcp Xfire 非官方 26000/tcp,udp Id Software’s Quake server, 官方 26000/tcp CCP Games’s 星战前夜 Online gaming MMORPG, 非官方 27000/udp (through 27006) Id Software’s 雷神世界 master server 非官方 27010/udp Half-Life及其修改版，如反恐精英系列 非官方 27015/udp Half-Life及其修改版，如反恐精英系列 非官方 27374 Sub7’s default port. Most 脚本小子s do not change the default port. 非官方 27500/udp (through 27900) Id Software’s 雷神世界 非官方 27888/udp Kaillera server 非官方 27900 (through 27901) 任天堂 任天堂Wi-Fi连接 非官方 27901/udp (through 27910) Id Software’s 雷神之锤II master server 非官方 27960/udp (through 27969) 动视’s Enemy Territory and Id Software’s 雷神之锤III竞技场 and Quake III and some ioquake3 derived games 非官方 28910 任天堂 任天堂Wi-Fi连接 非官方 28960 决胜时刻2 Common Call of Duty 2 port - (PC Version) 非官方 29900 (through 29901) 任天堂 任天堂Wi-Fi连接 非官方 29920 任天堂 任天堂Wi-Fi连接 非官方 30000 Pokemon Netbattle 非官方 30564/tcp Multiplicity：keyboard/mouse/clipboard sharing software 非官方 31337/tcp Back Orifice - remote administration tool（often 特洛伊木马 (计算机)） 非官方 31337/tcp xc0r3 - xc0r3 security antivir port 非官方 31415 ThoughtSignal - Server Communication Service（often Informational） 非官方 31456-31458/tcp TetriNET ports (in order: IRC, game, and spectating) 非官方 32245/tcp MMTSG-mutualed over MMT (encrypted transmission) 非官方 33434 Traceroute 官方 37777/tcp Digital Video Recorder hardware 非官方 36963 Counter Strike 2D multiplayer port (2D clone of popular CounterStrike computer game) 非官方 40000 SafetyNET p 官方 40523 data packets 不确定 6 43594-43595/tcp RuneScape 非官方 47808 BACnet Building Automation and Control Networks 官方 参考资料 维基百科-TCP/UDP端口列表]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>知名端口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客小知识]]></title>
    <url>%2Fbloginfo.html</url>
    <content type="text"><![CDATA[收集记录自己使用到的优化个人博客的知识和技巧，水滴石穿。 [2019年6月30日] Hexo 添加图表Mermaid特性Hexo中插入mermaid diagrams 安装插件：npm install hexo-filter-mermaid-diagrams 配置hexo下面的_config.xml, 下面的配置增加到最后 123456# mermaid chartmermaid: ## mermaid url https://github.com/knsv/mermaid enable: true # default true version: &quot;7.1.2&quot; # default v7.1.2 options: # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js #startOnload: true // default true js文件修改 修改位置 （next主题为例）themes/next/layout/_partials/footer.swig footer.swig 最后添加下面的内容12345678&#123;% if theme.mermaid.enable %&#125; &lt;script src=&apos;https://unpkg.com/mermaid@&#123;&#123; theme.mermaid.version &#125;&#125;/dist/mermaid.min.js&apos;&gt;&lt;/script&gt; &lt;script&gt; if (window.mermaid) &#123; mermaid.initialize(&#123;&#123; JSON.stringify(theme.mermaid.options) &#125;&#125;); &#125; &lt;/script&gt;&#123;% endif %&#125; Hexo 使用七牛图床如何用七牛和picGO设置免费图床其中存储区域可以根据七牛官网查到，我的存储空间时华北的，所以设置为z1。 Hexo 站内链接 首先参考参照站内的 “文章链接变更为永久链接”, 为每篇文章添加urlnameeg：我的《【网络编程】【RIB表与FIB表、ARP表与FDB表】》 文章对应的urlname是net_network_arp 链接过程中直接添加${urlname}.htmleg: 我想要链接《【网络编程】【RIB表与FIB表、ARP表与FDB表】》文章【网络编程】【RIB表与FIB表、ARP表与FDB表1[【网络编程】【RIB表与FIB表、ARP表与FDB表](net_network_arp.html) Hexo博客文章置顶功能Hexo文章置顶的方法 Hexo添加站内搜索Hexo开启站内搜索功能1.hexo添加搜索插件2.next主题启用搜索 自定义Hexo博客的文章模板模板目录：scaffolds1234├── scaffolds│ ├── draft.md //默认的草稿模板│ ├── page.md //默认的页面模板│ └── post.md //默认的文章模板 可以在下面新增自己的模板格式：123cp post.md name.md //name: 新模板名称vi name.md //编辑自己的文章模板hexo new name &quot;my new blog&quot; //新建文章时使用新模板]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>Hexo博客,技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客历程]]></title>
    <url>%2Fblogcourse.html</url>
    <content type="text"><![CDATA[2019年6月29日 – 文章刷新学习力：颠覆职场学习的高效方法 文章刷新读书笔记。 2019年6月16日 – 新增文章新增如下文章：1.学习力：颠覆职场学习的高效方法 2019年6月1日 – 新增文章新增如下文章：1.todo2.【技巧】【github】 2019年6月1日 – 增加站内搜索,文章置顶,网络编程文章 Hexo开启站内搜索功能1.hexo添加搜索插件2.next主题启用搜索 Hexo文章置顶的方法top 对应的value可以填写数字，数字越大排名越靠前。 新增,迁移自己的csdn文章1.Excel 技巧2.【网络编程】3.【网络编程】【RIB表与FIB表、ARP表与FDB表】4.【网络编程】【邻居表】 2019年5月22日 – 新增《高效工具》记录平时遇到比较好用的工具 2019年5月19日 – 文章链接变更为永久链接修改前：http://***/2019/05/19/tcp-ip-port/修改后：http://***/tcp-ip-port.html 优点 可以方便的管理自己的本地文章 当文章添加站内链接时，比较方便 参考资料 永久链接管理 2019年5月19日 – 新增《ftp协议》总结ftp协议相关技术 2019年5月19日 – 新增《知名端口号》记录通信协议中常见的端口号 2019年5月17日 – 新增《Hexo博客小知识》文章记录Hexo的使用技巧 2019年5月17日 – 新增博客的分类参考资料： 创建分类页面 2019年5月17日 – 新增《个人博客历程》文章记录博客的重要变更]]></content>
      <categories>
        <category>历程</category>
      </categories>
      <tags>
        <tag>历程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[烤冷面]]></title>
    <url>%2Fkaolengmian.html</url>
    <content type="text"><![CDATA[烤冷面，是一道黑龙江常见的地方特色小吃。有碳烤、铁板烤和油炸三种，味道各有差异。目前主要流行铁板和油炸。烤冷面的成本低，味道极棒。油炸烤冷面制作方法简单，可以用鸡蛋，香肠等辅助材料，主要由酱料作为调味剂。 起源据中共黑龙江省密山市委宣传部的官方微信公众号“密山发布”称，烤冷面于1996年前后发源于密山市第二中学附近，由一位名叫盖国峰的个体商贩无意中发明。对此有人提出异议，认为烤冷面源自牡丹江市，但也有牡丹江经营烤冷面的摊贩称其烤冷面技术源自密山，其真实起源已经无从考证，但不影响我们对美食的追求 做法早期所用冷面为普通冷面，制作工艺成熟后使用特制冷面，这种特制冷面比平常市面常见的冷面要薄、柔软，可直接食用。而铁板烤冷面可以添加鸡蛋、香肠、肉松、洋葱、香菜等，经过铁板的烘烤，涂上自己喜欢的酱料，松软可口酱香扑鼻，吃起来很劲道，非常受大众喜爱。 材料： 油适量，冷面（1张），洋葱10g。香菜5g，鸡蛋1个，烧烤酱适量，醋适量，孜然粉适量，糖适量，辣椒粉适量。 做法: 准备材料： 香菜和洋葱洗干净。冷面备好。这种冷面不是我们平常吃的用水煮的冷面，是成片，要比平常市面常见的冷面要薄、柔软，可直接食用，有专卖的地方。 香菜和洋葱切碎。 备好烧烤蒜蓉酱，鸡蛋打散鸡蛋是用一个打开一个，一张冷面一个鸡蛋。所以这里我先打散一个鸡蛋。 平底锅放油开火烧热，油可以随自己的喜好添加，喜欢油大就多加些，反之就少放一些，取一张冷面，放在油面上，小火煎。 打散鸡蛋液倒在冷面上，用平铲把鸡蛋液摊开。 鸡蛋液凝固后，翻到冷面，有鸡蛋液一面向下。一直是小火煎烤。 涂上一层烧烤酱。 撒上孜然粉，糖，辣椒粉，倒入适量醋，撒上洋葱和香菜，别忘了加上一根煎好的火腿肠 待鸡蛋熟透，卷起再刷一层烧烤酱。取出切块食用。（当然也有撒芝麻的，这个看自己口味） 卷好的成品]]></content>
      <categories>
        <category>美食</category>
      </categories>
      <tags>
        <tag>冷面，美食</tag>
      </tags>
  </entry>
</search>
